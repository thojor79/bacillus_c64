ToDo - in categories
============================

BUGS
====

Raster time is not enough for all tasks, if there are many enemies on
screen. We could distribute work over frames or start copying the color ram
earlier to solve the problem. The latter would be the easiest solution.
Alternativly interpolate linearily every 2nd frame.
The animated characters and the enemy computation takes too much raster
time. Alternativly we could compute new charset over various frames and
switch to it when it is done.

Green tiles are somehow broken, the number of characters used seems wrong,
so the number of chars with animation don't match.
maybe trap animation tiles use not the same chars as usual
trap tiles are #12 and #13, chars 2e,2f,32,33.
but green tile data as well. maybe tiledata converter reuses chars...
no. weird.


VISUAL GLITCHES
===============

blend_in: sprites delay raster irq most probably and give visual glitch, but
not critical. maybe just disable scorepanel by setting fgcol to all
black then


GAMEPLAY EXTENSIONS
===================

some simple tune or at least sound effects would be cool,
maybe one voice for effects, two for tune.
effects like explosion/gun can easily be done for killing enemy or
collecting boni. however playing sfx needs some code of a sidplayer
that is run every frame and this is not simple. maybe it is sufficient to
set up an instrument and play it for a certain amount of time, maybe it
needs more work. a music player then needs to keep one channel free.


GENERAL FEATURES
================

implement blend out effect for level end - reverse reading of blend in,
rather easy to do but low effect

Maybe change background color in intro screen per line for an effect or use
tech tech to wobble image. Maybe also for outtro text.


MORE DATA
=========

finish green world tile sets: bubbling brown pool as trap, only use it in
lowest row then.
paint tree with brown/green/light green as obstacle B and only use it in
second lowest row.
Green vines as spiral / twisted as obstacle A.
Green/brown islands with roots at bottom or just green as islands.
Roots with some green as ceiling.



INFO
====

Background tiles with parallax scrolling need to be hires. If they would be
multicolor, the scroll code would rotate bits, not bit pairs, so colors
would oscillate.

in interrupts don't save Y register if we don't change it - only in
scoreline irq, and not really critical there

traps are checked directly for player pos, so player can jump on a platform
where traps are on and is not killed as long as he is far enough to
left/right from the trap. Thats kind of a bug, but it doesnt matter for most
game situations, so we dont care.

NOTE that changing charset after display of level tile data would be good,
so tiles could use all 256 chars, optimally use last charset and last 20
characters of it (charset at $F800), except last char (where IRQ vectors
are), so only 168 bytes are lost for sprite data. However changing the
VICMEMCTRL register in time (needs a bad line) doesn't work stable and
blend_in sprites further complicates it, so sacrifice 20 characters of tile
charset for now.
With later games we can use a bigger score panel and more raster lines for
transition so we can do that more easily.

Maybe animated boni tiles in hires with white border and white logo like
rotating molecule or jumping water drop, better than what we have now.
No, it doesn't look good.

Scrolling is NOT done in the raster irq, but in main CPU code when bottom of
screen is reached (raster line 251). We also shift color RAM then, which is
the most critical part for timing.
It takes at least 147 raster lines (150 lines ~ 9000cyc with badlines, so
~9cyc per byte to copy, that is rather fast)


Ideas for later
===============

Many illegal opcodes of the C64 are very handy. Use them more in the code.

Many checks like collisions between player and enemy doesn't need to be done
every frame with 50fps, every 2nd or 4th frame is ok. For more than 7
enemies with sprite multiplexer this will be necessary as time is not enough
to do it every frame.

main screen: let sprites walk in from left/right below highscore until mid
of screen, then back again, so show all sprites, like a demo.

main screen: color cycling in text? e.g. color gradient horizontally that
moves quick.

Reorder trap animations and use them in forward order as originally
intended.

the animation of the background tile should be level dependant
easier to do it with separate data or separate code.
generation of animation could be done at runtime, as it is now.

implement more actor behaviors
Behaviour: follow player, flying pattern, flying homing
maybe use only 8 enemies with 1 bit to control behaviour - would reduce
sprite data as well - but also ok to use 16 as it is now

secret passages or rooms in levels - not for this game

player can shoot - not for this game

animate boni tiles

use spare sprites with actor numbers >= 16 as boni or traps.

boss monster - only sensible when player can shoot - not for this game

jump from below to walls for boni - not for this game

if we have only 64 tiles and 8 background tiles as now we can use 24 actor
types, not 16, by using bit6|bit7 as flag of actor! But 16 is enough for
now.

Create or rip some sound effects or music, maybe even try GoatTracker would
be cool. But composing would give most probably poor results due to lack of
experience with high effort. Ripping would be easier.

image converter could change hue of colors of whole image and also
brightness etc to give better results? but rarely needed...

Killed enemy sprite could change to a sprite showing the score that was
added for the kill and the score raises for 1-2 seconds above the enemy
position...

music and sfx is important! play 1-3 sfx or play music in a level. play an
existing SID file would be simplest solution, however we can't distribute it
because of rights? or are they free?

animate level tiles like vertically or horizontally rotating cheese rolls,
maybe better in candy world (later)

implement part of image converter with rle encoding (for logo in upper part
of screen only!)

multicolor extra colors can be changed in certain lines with rasterirq, to
bring more colors, but not easy to manage (the game creatures does it that
way)


Ideas for other games / projects
================================

8-way scrolling and sprite multiplexer would be cool, that way one can
create a Turrican like game. Also shots as characters are needed then, do
the shots check if an enemy is over them or does every enemy check all
characters below it?

Ultimate coding would be 8way scrolling 50fps maybe with some background
parallax scrolling and also sprite multiplexer (24 sprites or so) and maybe
sound playing. Only possible with interleaved AI/physics.

However randomly or procedurally generated content would be cool. Like a RPG
game with huge world map (256x256 maybe) so that the C64 can generate the
data on the fly. Would also be more interesting to play in unknown data.
Could be done for jump and runs or shoot em ups as well but much harder to
have playable and funny levels that way.

Creating good graphics isn't easy, converters are not smart enough. So
writing adventure games isn't that easy and it will take much space to use
multicolor graphics. Without scrolling we can store multicolor tiles and
build up a screen with them to have more colors. It will take much more ram
though. But would be an alternative. Designing graphics is hard, making the
simple levels of bacillus is no fun, if we could generate levels in 2d as
well like turrican it may be better. However content creation is not that
fun for programmers, so automatic generation is a possible alternative.

Space for multicolor tiles: 2x2 tiles are 4*8 bytes pixel data and 2*4 bytes
color data = 40 bytes per tile. With 4x4 tiles it is 160 bytes per tile. How
many tiles could we store? Up to 256 are possible, using 10k or 40k of
memory. Level data would take 200 bytes per screen or 50. For a large level
with 100 screens this would be 20k or 5k. Together 30k or 45k of ram, if
there are no meta tiles. 30k seems doable, but 45k is too limited, we need
space to render to and sprites etc. 17k roughly are used for that, what
would leave 17k or 2k for code. 17k seems doable, but not 2k.
So we could create a game multicolor room based with 100 rooms. With many
different tiles for walls we could create some dungeon master like game.
Various types of wall bricks and decorations, traps, gates, doors etc would
fit in memory. Generate appearance of screen by general locality and
position dependent pseudo randomness. It would be easy to fit a large
labyrinth into memory. we don't need to use tiles for this but just various
parts of graphics that are combined. if labyrinth shape, monsters and goods
are distributed randomly it will be a bit like nethack. rooms will need to
get generated as well.

what can easily be done with c64fy is conversion if line drawings to c64
pictures like the turrican2 intro.

How can we make use of modern computers and computing power for c64 games?
creating graphics and converting them or finding formulas for content
generation is a possibility. Here is another idea.
Use multicolor graphics mode for a game. Place all graphics in RAM, so no
need to load them. Construct screen of several layers of graphics, e.g.
three layers with fix distances. For every layer have N different graphics
that can be placed at fix positions, that means char blocks. Have e.g.
foreground layer with 12x8 sized graphics (blocks) and medium layer with 9x6
and distant layer with 6x4 or so. Store images in ram and compose screen by
them. Have e.g. background color blue and black/grey/brown with raster irq
to switch at same height. Clouds could be sprites moving behind pixels, in
sky there are no enemies, so can reuse sprites. have e.g. also sun as
sprite. Use 90Â° turns and discrete steps. Have pseudo random generated
256x256 map that tells per position wether road,gras,bush,tree,rock,house
etc. then take the nearest 5x5 fields or some cone-like area to render the
current screen. So we can store huge map in ram and huge world to explore.
rendering is done with cool trick: every subimage of NxM blocks consists of
pixel data and colors. it is rendered at any block of the screen. The
background color is not written, only the three other colors. Render each
block. If its colors are equal to that already on screen, just copy it. If
colors are all existent, but different order, swap bit data. If three new
colors are partly or fully not existing, have some computation, count for
every existing color how many pixels are there and for the new colors as
well. Use the three colors with highest count. replace other colors by
possible mix of the three colors. Maybe better to not keep the three most
used if two of them are similar, but rather keep one different color or so,
to minimize total error. Here some testing and research needs to be done.
Similar to c64fy. Have the graphics either packed by exomizer or even better
idea: place all of them in a large image and run c64fy to generate 512, 1024
or even 2048 characters. Then for every block of a subimage have 3 bytes, 2
with char index and one color, 1 byte with two other colors. so only 3 byte
per block. that way we can compress graphics well.
we need 16k for screen and sprites, code size will certainly be also minimum
16k, so at max 32k for graphics. With 1024 chars it would take 8k for pixel
data and we could store roughly 2730 blocks. That would be 10-12 subimages
per layer. 3 trees, 2 plants, 2 road, 1 bush, 1 rock, ... maybe some house
data as well. Maybe mountains below clouds also as sprites. Have upper part
of screen for display, 40 blocks wide, at most 20 blocks high.
E.g. first layer 5 subimages of 10x8 or 12x8 blocks. second layer 4 blocks
upwards with 8x6 size (2+6*6+2), third layer 3 blocks upwards with 8x5 size,
as example. depends if it works to pack that many graphics in 1024 chars.
Rendering isn't time critical and would work fast enough. would be very cool
result and we can use converter and generator to pack all graphics into 64k.
Problem is as with most graphics, just converting doesn't help much, one
needs rather some direct drawing, or rework the converted graphics with hand
pixel drawing. And this means many graphics need to be drawn just to test
wether the idea would give convincing results. It is a great idea and will
certainly work but how good the graphics will be is uncertain. The question
is also if the screens would differ enough from each other to make the game
playable. E.g. if player walks through a forest, many screens could look the
same. Maybe don't store full trees but vertical layers of leaves, a set of
trunks etc. and combine it. Pine trees can have various vertical layers of
needle leaves.

Rendering: store rectangular images of block size (multiples of 4x8 pixels,
so 8 bytes per block plus 2 bytes color).
Only render to full blocks, so positioning x/y only at multiple of 4/8
pixels. Image has one neutral color optionally. So either copy blocks fully
or mask them out and blend them in:
a bitmap byte has 4 pixels with 2 bit each. To generate the mask for the
byte do:
a = byte & 10101010
b = byte & 01010101
m = (a >> 1) | (b << 1) | byte
so mask has 1 bits where image data is.
screen-byte & ~m | (byte & m)
to compute blending in.
But only if the 3 colors of the image block already exist in screen block.
If not, count screen block colors and buffer colors, as first convert screen
block to 4*8 bytes with a color index per byte. Then copy image block with
masking to the scratch buffer. As best place the 32 byte scratch buffer in
zero page. Then count for all 16 colors that are not background color how
often they are used. The 3 most used colors will be the new block colors.
Replace other colors by one of the 3 new with least error. Have a 16x16
error matrix table in memory. Error is 0...255. Replace every color by least
bad alternative. Then convert scratch buffer back to screen block.
What will it cost? For every pixel there are surly ~20 cycles for
conversion, copy from and to screen and from image takes 60 cycles per
pixel, counting error and checking and replacing color say 20 more cycles
per pixel, so 80*32=2560 cycles per block. As a very rough guess. That would
take 50 raster lines per block. That would be 2.6ms per block. For full
screen with large area of 20x10 blocks that would be 500ms or 0.5seconds to
fill the screen but that would rather be fast - if we don't have overdraw.
However we certainly have factor 2 to 3 with overdraw so 1.0-1.5 seconds to
render a screen, what would be still good.
Advantage: every operation is rather simple.
The idea can be tested with a simple python program first! so if the screens
don't look good we can stop it, otherwise implement the concept.
We would need many graphics of tree trunks and leaves etc.
Overdraw could be much larger. Preparing images in gimp would be rather
easy. Rendering brick walls could be simple by placing repeatable pattern in
multiple of blocks.

SID Composing
=============

as first collect instruments from other tunes, this seems difficult to write
own instruments.
understand/learn what filter and pulse tables are.
maybe easier to get some notes and write them, free composing is very
difficult, music sounds ok, but rather mechanical.
