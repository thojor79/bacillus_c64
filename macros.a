; Collection of handy/useful macros
; (C) 2016/17 Thorsten Jordan

; add value to x register
!macro addx .value {
	txa
	sbx #(256 - .value)
}

; copy 8 bit value
!macro copy8 .dst, .src {
	lda .src
	sta .dst
}

; copy 16 bit value
!macro copy16 .dst, .src {
	lda .src
	sta .dst
	lda .src+1
	sta .dst+1
}

; set 8 bit value
!macro set8im .target, .val {
	lda #.val
	sta .target
}

; set 8 bit value indexed
!macro set8imx .target, .val {
	lda #.val
	sta .target,x
}

; store 16bit value (i.e. address)
!macro set16im .target, .val {
	lda #<.val
	sta .target
	lda #>.val
	sta .target+1
}

; add unsigned 8 bit value to 16 bit value (works only for unsigned values!)
!macro addu8to16 .result, .src {
	lda .src
	clc
	adc .result
	sta .result
	bcc +
	inc .result+1
+
}

; add signed 8 bit value to 16 bit value
!macro adds8to16 .result, .src {
	lda .src
	bpl +
	dec .result+1
+	clc
	adc .result
	sta .result
	bcc +
	inc .result+1
+
}

; add 16bit values
!macro add16 .result, .opA, .opB {
	lda .opA
	clc
	adc .opB
	sta .result
	lda .opA+1
	adc .opB+1
	sta .result+1
}

; add immediate 8bit value to memory
!macro add8im .dest, .val {
	lda #.val
	clc
	adc .dest
	sta .dest
}

; add immediate 8bit value to memory indexed
!macro add8imx .dest, .val {
	lda #.val
	clc
	adc .dest,x
	sta .dest,x
}

; add immediate 16bit value to memory
!macro add16im .dest, .val {
	lda #<.val
	clc
	adc .dest
	sta .dest
	lda #>.val
	adc .dest+1
	sta .dest+1
}

; add immediate 8bit value to 16bit memory
!macro add16im8 .dest, .val {
	lda #<.val
	clc
	adc .dest
	sta .dest
	bcc +
	inc .dest+1
+
}

; add immediate 16bit value to operand and store to memory
!macro add16opim .dest, .src, .val {
	lda #<.val
	clc
	adc .src
	sta .dest
	lda #>.val
	adc .src+1
	sta .dest+1
}

; subtract immediate 16bit value to memory
!macro sub16im .dest, .val {
	lda .dest
	sec
	sbc #<.val
	sta .dest
	lda .dest+1
	sbc #>.val
	sta .dest+1
}

; subtract immediate 16bit value from operand to memory
!macro sub16opim .dest, .src, .val {
	lda .src
	sec
	sbc #<.val
	sta .dest
	lda .src+1
	sbc #>.val
	sta .dest+1
}

; subtract 16bit values
!macro sub16 .result, .opA, .opB {
	lda .opA
	sec
	sbc .opB
	sta .result
	lda .opA+1
	sbc .opB+1
	sta .result+1
}

; compute 16bit absolute value
!macro abs16 .adr {
	lda .adr+1
	bpl +
	eor #$FF	; negate
	sta .adr+1
	lda .adr
	eor #$FF
	clc
	adc #1
	sta .adr
	lda .adr+1
	adc #0
	sta .adr+1
+
}

; compute absolute difference of 16 bit values - code longer but maybe a bit faster than separate sub/abs.
!macro absdiff16 .result, .opA, .opB {
	lda .opA+1
	cmp .opB+1
	beq ++
	bcc +
	; A > B
	+sub16 .result, .opA, .opB
	jmp +++
+	; B > A
	+sub16 .result, .opB, .opA
	jmp +++
++	; Hibyte equal, so check lowbyte
	lda #0
	sta .result+1
	lda .opA
	cmp .opB
	beq ++
	bcc +
	; A > B, Alow already in Accu
	sec
	sbc .opB
	sta .result
	jmp +++
+	; B > A
	lda .opB
	sec
	sbc .opA
	sta .result
	jmp +++
++	lda #0
	sta .result
+++
}

; clear 1K of memory
!macro memset1K .dstadr, .value {
	lda #.value
	ldx #$00
-	sta .dstadr,x
	sta .dstadr+$100,x
	sta .dstadr+$200,x
	sta .dstadr+$300,x
	inx
	bne -
}
; Copies 64 bytes
!macro memcopy64 .dstadr, .srcadr {
	ldx #$00
-	lda .srcadr,x
	sta .dstadr,x
	inx
	cpx #64
	bne -
}

