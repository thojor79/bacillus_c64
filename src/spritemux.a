; Bacillus_c64
; Copyright (C) 2016-2017  Thorsten Jordan.
; 
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ***************************************************************************************
;
;    sprite multiplexer V2.0
;
; ***************************************************************************************

NR_OF_VIRTUAL_SPRITES = 32 ; rather test 24 or less sprites, works with 44, min 2 (<8 doesn't make sense though)
MIN_SPRITE_Y = 30
MAX_SPRITE_Y = 250
SPRITE_Y_DISTANCE = 21		; This is just the sprite height.
UNROLL_FULL_IRQ = 0
SPRITE_PREPARE_RASTERLINE = 250

;TESTING = 1
;DEBUG_TIMING = 1
;TEST_STATIC_POS = 1
;KERNAL_RAND_POS = 1

; Preparation of the sprites is done in an IRQ at the bottom of the screen (scorepanel).
; Thus it can never be delayed by the screen data transfer when scrolling and the
; preparation can not be interrupted by the next sprite irqs, which is good.
; We need to prepare all of them first anyway before setting them up.

; A sprite multiplexer uses the eight hardware sprites that are reprogrammed with raster IRQs to display
; a larger number of virtual sprites.
; For that it is essential to have very low overhead in the IRQ code so the raster IRQs can be called
; often and quickly reprogram the sprite registers.
; The data for the IRQs is prepared when no sprites are visible, at bottom of the screen, this is
; the preparation phase.
; For every sprite at least four registers have to be set on the IRQ: x, y, pointer, color and we need
; to set the register for the 9th bits of the x coordinates.
; The fastest way to set registers is a direct LDA #immediate, STA $D0XX pair with 6 cycles per register
; set. An older version of this muxer did it that way but this is only possible by manipulating the IRQ
; code every frame which costs much preparation time.
; By reading the values from zeropage or normal memory this takes 7 or 8 cycles per register, which is
; still fast enough for IRQs but makes the preparation code faster.
; So this version of the sprite multiplexer (muxer) uses this approach with still low IRQ overhead.
; See below for more IRQ details.
; Here are more details on how it works:
; The preparation stage copies the virtual sprite data and sorts the sprites by their Y coordinate.
; Sprites that are invisible or would become the 9th hardware sprite on a row are skipped.
; The first eight sprites are displayed directly. More virtual sprites need raster IRQs
; to be fired early enough before their rasterline has come to reprogram the sprite registers.
; IRQs can be triggered as soon as a hardware sprite has finished display or shortly before it has to be displayed.
; This code uses the latter method and also computes in the preparation phase which other hardware sprites could
; be reprogrammed in the same IRQ because their display has also been finished.
; The preparation keeps the sorted Y values and sorts them again with insertion sort in the next frame.
; Normally Y coordinates don't change that often, so the sorting code hasn't much to do in most frames.
; This is the fastest solution for sorting, but it still takes many rasterlines.
; We need to sort indices to the virtual sprites instead of just Y coordinates, so the sorting algorithm needs
; double indirection. A faster solution to just sort the Y coordinates directly isn't useful.
; The preparation time should be as short as possible which is achieved here with one extra
; computation. If more than one sprite is displayed in a raster IRQ we have to trigger that IRQ earlier. Older
; versions or other muxers simply compute how many sprites need to be programmed and decrease the raster line
; for trigger accordingly. But it can be done better: for every sprite take its Y coordinate and compute how many
; sprites are programmed before that in the same IRQ and decrease the raster line according to that number,
; then take the total minimum of all these numbers. If all displayed sprites would have the same Y coordinate
; the result is the same as with other muxers, but if the IRQ is triggered with enough distance to the other
; sprites in the IRQ we can trigger it shorter before the first. This allows for tighter sprite formations
; on the screen without visual errors. This extra computation step takes ~6 raster lines in preparation
; stage.
; Now for the overhead in the IRQ. By using the lda memory, sta $D0XX approach we can use an IRQ that only
; modifies the accumulator, so we don't need so save X/Y registers. The IRQ code is unrolled for every virtual
; sprite above the first eight. IRQ entry can be at any virtual sprite. As first the xhigh register is set for
; all sprites, then the four registers are set for each individual sprite. If the highest bit of the color is set
; the IRQ ends. If not the next unrolled virtual sprite code block is run.
; Now there are two options: full unrolling vs. partial unrolling.
; With partial unrolling it takes 38 bytes for the IRQ code per virtual sprite. When the IRQ ends we do a JSR to a
; routine that uses the calling address on the stack to start the next IRQ there.
; With full unrolling it takes 83 bytes for the IRQ code per virtual sprite. When the IRQ ends the address to
; call the next IRQ is just set by every unrolled code block. Interrupt exit code is contained in every block.
; This saves 20 cycles on exit of every IRQ and 14 for the last IRQ. Even less overhead with the cost of
; much memory. Normally this extra saving of cycles isn't worth the additional used RAM.
; So as memory usage for the IRQ code this gives in bytes:
; Nr. virt. Sprites   Fully unrolled   Partially unrolled
; 12                   296              215
; 16                   628              367
; 20                   960              519
; 24                  1292              671
; 28                  1624              823
; 32                  1956             1127
; Note that sprite data doesn't need to be in zeropage, but IRQ is faster that way and we have enough space
; in the zeropage.
; Note that at the end of an IRQ we have to check if we are late for the next IRQ and if so, we must do
; busy waiting in the IRQ. With tight sprite formations this eats away much time, but it must be done to
; avoid visual glitches.
; 
; For debugging the background color is modified in preparation phase and also for displaying.
; Light grey is IRQ code time and black is busy waiting time.

; Some notes for incorporating the muxer in a game with scrolling:
; The lower copy of the color ram is triggered when the raster irq is at half of screen,
; however this would interfere with the sprite raster interrupts. So check the raster line
; during game logic update and do the color ram copy in main cpu thread!

; Note charset blends over sprite data for test from sprite 30 on


!if TESTING {
TEMP0 = 2
TEMP1 = 3
TEMP2 = 4
TEMP3 = 5
TEMP4 = 6
TEMP5 = 7
TEMPADR0 = 8
TEMPADR1 = 10
VICBGCOL = $D020
VICFGCOL = $D021
VICCTRL2 = $D016
VICMEMCTRL = $D018
VICCTRL1 = $D011
VICRASTER = $D012
VICIRQMASK = $D01A
VICSPRITEENABLE = $D015
CIA1_ICR = $DC0D

!to "test/spritemux.prg", cbm

!src "src/macros.a"

*= $0801	; Program start at 2049

; Basic start code 1979 SYS2066:REM TJ
!byte $10,$08,$BB,$07,$9E,$32,$30,$36,$36,$3A,$8F,$20,$54,$4A,$00,$00,$00

main
	jmp +
; for easier debugging
!byte <vsprite_y
!byte >vsprite_y
!byte <(sprite_mux_irq_code_end-sprite_mux_irq)
!byte >(sprite_mux_irq_code_end-sprite_mux_irq)
!byte <MUXIRQ_SIZE
!byte >MUXIRQ_SIZE
+
	; Set position and move values with randomness from kernal code
	; Positions
!if KERNAL_RAND_POS {
	ldx #NR_OF_VIRTUAL_SPRITES-1
main_prep_pos_dxy
	lda $E000,x
	sta vsprite_xl,x
	lda $E018,x
	and #1
	sta vsprite_xh,x
	lda $E030,x
	sta vsprite_y,x
	; Deltas
	lda $E048,x
	and #3
	clc
	adc #1
	sta vsprite_dx,x
	lda $E060,x
	and #1
	clc
	adc #1
	sta vsprite_dy,x
	dex
	bpl main_prep_pos_dxy
}
	; Set up generic IRQ handling (only raster irqs)
	sei
	+set8im VICRASTER, 0
	+set8im VICCTRL1, $1B	; clear 9th bit of raster line selector, set mc mode
	+set8im VICIRQMASK, $01	; Set only raster as source for IRQ of VIC (default $F0)
	lda #$7F		; disable timer IRQs
	sta CIA1_ICR
	lda CIA1_ICR		; ack CIA irq
	asl $D019		; Acknowledge possible pending raster irq
	+set8im 1, $35		; only I/O, no kernal
	jsr sprite_mux_init
	; wait for raster at top, when preparation irq is done
--	lda frame_counter
-	cmp frame_counter
	beq -
!if TEST_STATIC_POS {
	jmp --
	; even rts is possible, if we allow other irqs and keep kernal etc.
}
	; increment x/y and repeat.
	ldx #NR_OF_VIRTUAL_SPRITES-1
-	lda vsprite_xl,x
	clc
	adc vsprite_dx,x
	sta vsprite_xl,x
	lda vsprite_xh,x
	adc #0
	sta vsprite_xh,x
	beq +
	lda vsprite_xl,x
	cmp #80
	bcc +
	; x >= 336, set to 24
	dec vsprite_xh,x
	lda #24
	sta vsprite_xl,x
+
	lda vsprite_y,x
	clc
	adc vsprite_dy,x
	; avoid $FF as value! that is end marker - would kill displaying
	cmp #$FF
	bne +
	lda #0
+
	sta vsprite_y,x
	dex
	bpl -
	; next frame
	jmp --

!src "sprites32_sprdata.a"	; sprites32_data

vsprite_dx
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!byte (((COUNT * 789) % 3) + 1)
}

vsprite_dy
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!byte ((COUNT * 337) & 1) + 1
}

}

; ------------ data for sprite muxer -------------

vsprite_y
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte <(50 + 3*COUNT)	; *5
		;!byte <((COUNT / 8) * 3 + (COUNT % 8) * 13 + 50)
	} else {
		!byte 0
	}
}
!byte 255	; y value to use as end marker (saves extra check in preparation loop!)

vsprite_xl
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte <(24 + (COUNT % 8) * 30 + (COUNT / 8) * 10)
	} else {
		!byte 0
	}
}

vsprite_xh
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte >(24 + (COUNT % 8) * 30 + (COUNT / 8) * 10)
	} else {
		!byte 0
	}
}

vsprite_ptr
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte (sprites32_data/64+COUNT)
	} else {
		!byte 0	
	}
}

vsprite_col
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte ((COUNT % 15) + 7) & 15
	} else {
		!byte 0
	}
}

bit_nand_table
!for BIT, 0, NR_OF_VIRTUAL_SPRITES-8-1 {
!byte 255-(1<<(BIT&7))
}

bit_or_table
!for BIT, 0, NR_OF_VIRTUAL_SPRITES-8-1 {
!byte (1<<(BIT&7))
}

; generic counter increased by every preparation irq so main program can react
frame_counter	; fixme maybe better in zeropage?
!byte 0

; Cycles needed for IRQ: 6-9 for IRQ itself, then pha/lda/sta=3+3+4=10
; every block takes: (3+4)*4+3=31 if the bpl is taken.
; This means cycles we need for N sprites:
; N	Cycles
; 1	41
; 2	72
; 3	103
; 4	134
; 5	165
; 6	196
; 7	227
; 8	258
; Worst case is one badline (22 cycles) and several normal lines (63 cycles),
; so we have cycles:
; Lines	Cycles
; 1	22-63
; 2	85-126
; 3	148-189
; 4	211-252
; 5	274-315
; Thus to be sure to display all sprites it takes worst case:
; N	Lines
; 1	1-2, rather 1, but at least 2!
; 2	2
; 3	2-3, rather 2
; 4	3
; 5	3-4, rather 3
; 6	4
; 7	4-5, rather 4
; 8	5
sprite_mux_irq_lines_before_sprite
!byte 2,2,2,3,3,4,4,5

; space needed: NR_VIRT for sort order, NR_V for sprite_sorted_y,
; (NR_V-8)*5 for the other values, so in total NR_V*7-5*8.
; For 32 sprites this would be 184 bytes of zeropage,
; for 24 sprites this would be 128 bytes of zeropage, thats ok.
; use one extra byte in sprite_sort_order as end marker to save one additional stop check in preparation loop!
; This saves 6*16=96 cycles in preparation loop at the cost of only 1 zeropage byte and 1 byte ram, seems good
sprite_sort_order = 64-1		; must be in zeropage because of stx xxx,y
; Note! The following data doesn't need to be in zeropage, but it is faster that way
sprite_sorted_y = sprite_sort_order + NR_OF_VIRTUAL_SPRITES + 1	;$40+$18=$58, for 16
slot_d010 = sprite_sorted_y + NR_OF_VIRTUAL_SPRITES		;$58+$18=$70
slot_xl = slot_d010 + NR_OF_VIRTUAL_SPRITES-8			;$80
slot_ptr = slot_xl + NR_OF_VIRTUAL_SPRITES-8			;$90
slot_col = slot_ptr + NR_OF_VIRTUAL_SPRITES-8			;$a0
slot_raster = slot_col + NR_OF_VIRTUAL_SPRITES-8		;$b0


; Prepare the sprite multiplexer
sprite_mux_init
	; turn on all sprites
	+set8im VICSPRITEENABLE, $FF
	; prepare any initial sort order - must be in zeropage!
	ldy #NR_OF_VIRTUAL_SPRITES	; one more to also set sort index for stop marker!
-	tya
	sta sprite_sort_order,y
	dey
	bpl -
	; set up irq
	sei
	+set16im $FFFE, sprite_mux_irq_prepare
	+set8im VICRASTER, SPRITE_PREPARE_RASTERLINE
	cli
	rts

; *************************************************************
; Routine to prepare next frame's sprite data (IRQ!)
; *************************************************************
; sorts sprite indices by the sprite's y coordinate
; and prepares sprite interrupt data.
; NOTE!!! Not reentrant code! It uses zeropage variables without saving
; them! Either have 5 dedicated zeropage variables for this or don't allow
; game logic to be interrupted by that IRQ. Rather invest 5 more zeropage
; bytes!!! (fixme) maybe we can put some of these at the end of the arrays, xhval at the end of
; the xh array...
; Note that sorting uses TEMP0,TEMP1 which can reuse one of the other five variables.
; USES	TEMP0,TEMP1,TEMP2,TEMP3,TEMP4
SPRITE_MUX_XHVAL = TEMP0
SPRITE_MUX_SORT_INDEX = TEMP3	; index in sorted table
SPRITE_MUX_NRSPRINIRQ = TEMP1	; uses one byte, nr of sprites in current irq
SPRITE_MUX_CURRENT_RL = TEMP2	; uses one byte, current rasterline for irq
SLOT_NR_IRQ_BEGIN = TEMP4
; ************************************************************
sprite_mux_irq_prepare
!if DEBUG_TIMING { inc VICBGCOL }
	; This is also an irq and it should better not get preempted,
	; it could by sprite display irqs, but better not.
	; So we ack the irq only at the end!
	pha
	txa
	pha
	tya
	pha

	; Changing value for one sprite and sorting it in sorted list would be
	; logN (make heap). Hence all sprites can change position and mostly will
	; every frame, this is N*logN like heap sort. So this will NOT be faster.
	; The fastest continuous sorting algorithm is insertion sort.
	; We also tried bubble sort, which is faster on already sorted arrays
	; but will be very bad in certain yet realistic situations.
	; So use insertion sort here.
	; And just sorting the y values directly is faster, but we need to know
	; which indices are they for, so we would need to sort the index array
	; meanwhile. But since the sorted y values are not final and can't be kept
	; (because of the skip with 9th sprite on a row) we can't do that or need
	; to copy the y values to yet another array - as result it is not faster.
	; So do it with insertion sort of indexed coordinates.

	; as first sort indices so that sprite y coordinates are ascending with
	; insertion sort
	; outer counter of insertion sort loop is stored in y/TEMP0, going from 1 to
	; NR_OF_VIRTUAL_SPRITES-1. Inner counter is y register.
	; The virtual sprite number is in x register.
	; currently processed vsprite index in TEMP1, it's y value in accu
	; the sorting takes many cycles even for already sorted arrays, but we can't
	; remove more commands.
	; Can we speed up this code anyhow? X and Y are needed in inner loop,
	; so we need to use zeropage for storage. Seems this is the minimum
	; version for intersion sort. Either there is a faster algorithm for nearly sorted
	; lists or it just takes that long.
	; Sorting indices in reverse order to save the cpy call in the outer loop would
	; save at least that call, but that saves only ~3*24 cycles (1 rasterline) total.
	; Even with 32 sprites the sorting is fast enough in realistic situations.
	ldy #1			; outer counter 1...NR_OF_VIRTUAL_SPRITES-1
sprite_mux_sort_outerloop
	ldx sprite_sort_order,y
	lda vsprite_y,x
	sty TEMP0		; save outer counter
	stx TEMP1		; its sort_order[y], is overwritten so save it
sprite_mux_sort_innerloop	; since y>0 always we only check at end of loop
	ldx sprite_sort_order-1,y
	cmp vsprite_y,x		; compare to Y of processed index
	bcs sprite_mux_sort_innerdone
	stx sprite_sort_order,y
	dey
	bne sprite_mux_sort_innerloop
sprite_mux_sort_innerdone
	ldx TEMP1		; current index
	stx sprite_sort_order,y	; store sort_order[y]
	ldy TEMP0 		; load outer counter
	iny
	cpy #NR_OF_VIRTUAL_SPRITES
	bne sprite_mux_sort_outerloop
!if DEBUG_TIMING { inc VICBGCOL }

; next step: skip all sprites with y coords that are too low
; advance y register to first sprite index with visible sprite
; Note that we already start with Y=8 to avoid adding offset 8 later!
; Minus one because of iny before checking.
; Note that if all sprites are too low, this will completely run amok.
; But that case does never happen in practice.
	ldx #8-1
	lda #MIN_SPRITE_Y
-	ldy sprite_sort_order-8+1,x
	inx
	cmp vsprite_y,y
	bcs -

; now up to 8 sprites can be shown directly. Copy their sorted y coordinates
; to the zeropage arrays (we need them there for later lookup).
; We can set the other values directly.
; Do NOT break out when y coordinate is too high!
; Because if it is the sprite must not be used and we need to set some value
; for it so it is not displayed instead of turned off - and that is e.g. a
; high y coordinate!
; Logical consequence is: unroll the loop!
; we need to set the correct screen address later!
	+set8im SPRITE_MUX_XHVAL, 0	; prepare D010 (xh) register
sprite_mux_set_first8
!for COUNT, 0, 7 {
!zone {
.adrstart
	ldy sprite_sort_order+COUNT-8,x	; -8 because x already with offset 8.
	lda vsprite_y,y
	sta sprite_sorted_y+COUNT
	sta $D001+COUNT*2
	lda vsprite_xl,y
	sta $D000+COUNT*2
	lda vsprite_ptr,y
	sta $07F8+COUNT			; screen address needs replace later
.adrp1
	lda vsprite_col,y
	sta $D027+COUNT
	lda vsprite_xh,y
	beq +
	lda SPRITE_MUX_XHVAL
	ora #(1 << COUNT)
	sta SPRITE_MUX_XHVAL
+
.adrend
FIRST8_SCREEN_ADR = .adrp1 - .adrstart - 1
FIRST8_SIZE = .adrend - .adrstart
}
}
	lda SPRITE_MUX_XHVAL	; must be loaded again because the beq above may have been taken
	sta $D010		; save current xhigh value to register
!if DEBUG_TIMING { inc VICBGCOL }

; copy data for virtual sprites 8-x to irq code!
; up to x-8 iterations:
; load ycoord of next sprite.
; if it is too large, stop irq generation, finish last irq
; compare ycoord to that of 8 sprites before (same slot)
; if ycoord is too close, sprite would be 9th sprite in a rasterline, so skip it
; otherwise sprite can be displayed, but check if in this irq or in new irq
; if new irq, finish current irq and create next (if not first)
; append data to current irq
; while appending irq data update xhvalue
; when all is done, finish last irq
; the slot number is in Y (nr of virtual hardware sprite that is used),
; it runs from 0 to NR_VIRTUAL_SPRITES - 1 and is 8 after setup of the first
; 8 hardware sprites.

	stx SPRITE_MUX_SORT_INDEX	; save current index (some virtual sprites could have been skipped!)
	lda #0				; init data for routine
	tay				; slot nr = 0 initially
	sty SLOT_NR_IRQ_BEGIN
	sta SPRITE_MUX_NRSPRINIRQ
	sta SPRITE_MUX_CURRENT_RL	; first rasterline = 0 as marker, so comparison below is always false for first irq
sprite_mux_prepare_next_vsprite
	ldx SPRITE_MUX_SORT_INDEX	; get sort order index
	lda sprite_sort_order,x		; get sort order. 
	tax				; put it in x
	lda vsprite_y,x			; load next virtual sprite y coord
	cmp #MAX_SPRITE_Y		; check that sprite ycoord is visible
	bcs sprite_mux_irqs_prepared	; if too big, stop further displaying
	inc SPRITE_MUX_SORT_INDEX	; advance to next sorted index
	sta sprite_sorted_y+8,y		; save sorted y for later use (overwritten if sprite is skipped)
	lda sprite_sorted_y,y		; load sorted y of current slot (8 sprites before!)
	adc #SPRITE_Y_DISTANCE		; C=0 here, also afterwards, compute end of sprite display of that slot
	cmp sprite_sorted_y+8,y		; compare against current sprite y
	bcs sprite_mux_prepare_next_vsprite	; sprite would be 9th in rasterline, skip it!
	; sprite can be displayed - check if in this irq or new irq
	cmp SPRITE_MUX_CURRENT_RL	; compare y of last slot + 21 < current rasterline ?
	bcc sprite_mux_prepare_same_irq	; same irq can be used if this slot has finished drawing
	; need new irq
	lda SPRITE_MUX_CURRENT_RL	; load current raster line
	beq +				; if 0, this is first irq
	; not first (new) irq, finish last one
	; read the current irq rasterline start and store it for the slot at irq begin
	lda SPRITE_MUX_CURRENT_RL
	ldx SLOT_NR_IRQ_BEGIN
	sta slot_raster,x
	; prepare xhigh value
	lda SPRITE_MUX_XHVAL
	sta slot_d010,x			; store at matching slot
	sty SLOT_NR_IRQ_BEGIN		; memorize for next irq
	+set8im SPRITE_MUX_NRSPRINIRQ, 0	; 0 sprites in this irq
	; set highest bit of last written color to flag end of irq!
	lda slot_col-1,y		; write to slot before, so -1 here
	ora #$80
	sta slot_col-1,y
+
	lda #$FF			; real value is set later, use neutral value for mininum computation.
	sta SPRITE_MUX_CURRENT_RL	; save as rasterline
sprite_mux_prepare_same_irq
	ldx SPRITE_MUX_SORT_INDEX	; set x again to sort order
	lda sprite_sort_order-1,x	; -1 because y alreadly inc'd
	tax
	lda vsprite_xl,x
	sta slot_xl,y
	lda vsprite_ptr,x
	sta slot_ptr,y
	lda vsprite_col,x
	sta slot_col,y
	lda SPRITE_MUX_XHVAL		; xhigh
	and bit_nand_table,y		; slotnumber (NUM_VSPRITES-8 sized!)
	sta SPRITE_MUX_XHVAL
	lda vsprite_xh,x
	beq +
	lda SPRITE_MUX_XHVAL
	ora bit_or_table,y
	sta SPRITE_MUX_XHVAL
+	
	; load sprite y and decrease by offset depending on number of sprites in interrupt
	lda vsprite_y,x
	ldx SPRITE_MUX_NRSPRINIRQ
	sec
	sbc sprite_mux_irq_lines_before_sprite,x
	; compare if that is lower than current irq raster start, if so, use it
	cmp SPRITE_MUX_CURRENT_RL
	bcs +
	sta SPRITE_MUX_CURRENT_RL
+
	inc SPRITE_MUX_NRSPRINIRQ	; sprite handled
	iny				; use next slot
!if DEBUG_TIMING { inc VICBGCOL }
	jmp sprite_mux_prepare_next_vsprite

sprite_mux_irqs_prepared
!if DEBUG_TIMING { inc VICBGCOL }
	; store the irq start raster line for that slot
	lda SPRITE_MUX_CURRENT_RL
	ldx SLOT_NR_IRQ_BEGIN
	sta slot_raster,x				; to slot where irq begun
	; set xhigh value of last irq
	lda SPRITE_MUX_XHVAL
	sta slot_d010,x
	; if all virtual sprites are handled but not all slots used because some
	; sprites are skipped because of 9th sprite in a row or too small y coordinates
	; we have to signal the end of all irqs by setting 7th bit of color of last slot
	; and setting the next raster line to 0 as marker.
	; In that case y has not reached maximum value
	cpy #(NR_OF_VIRTUAL_SPRITES-8)
	beq +
	lda slot_col-1,y		; write to slot before, so -1 here
	ora #$80
	sta slot_col-1,y
	lda #0
	sta slot_raster,y
+	; how can we check that only 8 sprites are drawn and no irq is needed? slot nr is 0!
	; but xh is then already written, but that doesn't hurt, its the actual value
	tya	; shorter/faster than cpy #0
	bne +
	; only 8 sprites are drawn, set irq so that next frame is prepared
	+set16im $FFFE, sprite_mux_irq_prepare
	+set8im VICRASTER, SPRITE_PREPARE_RASTERLINE
	bne ++	; highbyte is !0, so always jumps
+	lda slot_raster
	; we are in irq, so we don't need sei/cli here.
	; using cli leads to graphical errors, sometimes sprites disappear then.
	; The reason is unknown, no other irq should happen during that time...
	sta VICRASTER
	+set16im $FFFE, sprite_mux_irq	; raster irq visits that address
	; set end marker for last irq (high bit of color) is not needed
++

; we need to set the hibyte of the screen address for all virtual sprites!
; so one load and 16-32 stores.
	lda #$07		; hibyte of screen address
!for COUNT, 0, 7 {
	sta sprite_mux_set_first8+COUNT*FIRST8_SIZE+FIRST8_SCREEN_ADR
}
!for COUNT, 8, NR_OF_VIRTUAL_SPRITES-1 {
	sta sprite_mux_irq_unroll+MUXIRQ_SIZE*(COUNT-8)+MUXIRQ_SCREEN_ADR
}
	; here the preparation ends, and this is an IRQ after all, so return from it
	pla
	tay
	pla
	tax
!if DEBUG_TIMING { +set8im VICBGCOL, 14 }
	pla
	asl $D019
	inc frame_counter
	rti


; ******************************************
; the magic sprite mux irq
; ******************************************
MIN_RASTER_LINES_BETWEEN_IRQS = 3	; with 2 we miss rasterlines/irqs and many sprites are missing
sprite_mux_irq

!if UNROLL_FULL_IRQ {


!if DEBUG_TIMING { inc VICBGCOL }
	pha				; save accu
	lda slot_d010			; load xhigh for irq start at that slot
	sta $D010			; set xhigh for this irq
sprite_mux_irq_unroll
	; unroll one iteration less than needed, last iteration is shorter and manually unrolled.
	; note that the instructions must be identical in the last iteration to make it work!
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-2-8 {
!zone {
.adrstart
	lda sprite_sorted_y + COUNT + 8	; load y coord
	sta $D001+(COUNT & 7)*2		; set for hardware sprite
	lda slot_xl + COUNT		; load xl coord
	sta $D000+(COUNT & 7)*2		; set for hardware sprite
	lda slot_ptr + COUNT		; load sprite pointer
	sta $07F8+(COUNT & 7)		; set in register
.adrp1
	lda slot_col + COUNT		; load color
	sta $D027+(COUNT & 7)		; set in register
	bpl .adrend			; if highbit set irq ends, so highbit clear, do next slot
	lda slot_raster + COUNT+1	; load next irq raster line, next so +1
	; when accu is 0 so zero bit is set, no new irq needs to be called
	; but the last one needs to end!
	bne +
	jmp sprite_mux_irq_last_done
+	sta VICRASTER			; set as irq trigger
	cld
	sec				; check if we are late for next irq!
	sbc #MIN_RASTER_LINES_BETWEEN_IRQS
	cmp VICRASTER
	; if C=0 we are too late for next irq, but do not start it BEFORE the
	; stored raster line or it will be too early!
	; if we are too late for the irq all displaying fails from here on
	bcc +				; if carry set, VICRASTER <= next_rasterline - 2, so end IRQ
	+set16im $FFFE, .nextirqstart
	pla		; restore accu
	asl $D019	; ack irq
!if DEBUG_TIMING { dec VICBGCOL }
	rti
+	adc #(MIN_RASTER_LINES_BETWEEN_IRQS-1)	; C=0, prepare check VICRASTER <= next_rasterline - 1
!if DEBUG_TIMING { inc VICBGCOL }
-	cmp VICRASTER			; as long as we are in line before, do busy waiting
	bcs -
!if DEBUG_TIMING { dec VICBGCOL }
	bcc +				; directly jump to next irq code (always branches)
.nextirqstart
!if DEBUG_TIMING { inc VICBGCOL }
	pha				; save accu
+	lda slot_d010 + COUNT+1		; load xhigh for irq start at that slot
	sta $D010			; set xhigh for this irq
.adrend
MUXIRQ_SIZE = .adrend - .adrstart
MUXIRQ_SCREEN_ADR = .adrp1 - 1 - .adrstart
} ; zone
} ; for
; Now iteration for COUNT=NR_OF_VIRTUAL_SPRITES-1-8 manually unrolled, only
; a few instructions. Must be identical to unrolled irq code!
!zone {
.COUNT=NR_OF_VIRTUAL_SPRITES-1-8
	lda sprite_sorted_y + .COUNT + 8	; load y coord
	sta $D001+(.COUNT & 7)*2		; set for hardware sprite
	lda slot_xl + .COUNT		; load xl coord
	sta $D000+(.COUNT & 7)*2		; set for hardware sprite
	lda slot_ptr + .COUNT		; load sprite pointer
	sta $07F8+(.COUNT & 7)		; set in register
	lda slot_col + .COUNT		; load color
	sta $D027+(.COUNT & 7)		; set in register
}
sprite_mux_irq_last_done
	; last irq is done, trigger preparation irq then
	+set16im $FFFE, sprite_mux_irq_prepare
	+set8im VICRASTER, SPRITE_PREPARE_RASTERLINE
	pla
!if DEBUG_TIMING { dec VICBGCOL }
	; ack and end irq
	asl $D019
	rti
sprite_mux_irq_code_end



} else {	; UNROLL_FULL_IRQ
	; here the partially unrolled version

!if DEBUG_TIMING { inc VICBGCOL }
	pha				; save accu
	lda slot_d010			; load xhigh for irq start at that slot
	sta $D010			; set xhigh for this irq
sprite_mux_irq_unroll
	; unroll one iteration less than needed, last iteration is shorter and manually unrolled.
	; note that the instructions must be identical in the last iteration to make it work!
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-2-8 {
!zone {
.adrstart
	lda sprite_sorted_y + COUNT + 8	; load y coord
	sta $D001+(COUNT & 7)*2		; set for hardware sprite
	lda slot_xl + COUNT		; load xl coord
	sta $D000+(COUNT & 7)*2		; set for hardware sprite
	lda slot_ptr + COUNT		; load sprite pointer
	sta $07F8+(COUNT & 7)		; set in register
.adrp1
	lda slot_col + COUNT		; load color
	sta $D027+(COUNT & 7)		; set in register
	bpl .adrend			; if highbit set irq ends, so highbit clear, do next slot
	lda slot_raster + COUNT+1	; load next irq raster line, next so +1
	jsr sprite_mux_irq_prepare_next	; save address for next irq or returns if late
	bcc +				; carry is clear from caller, so this always branches
!if DEBUG_TIMING { inc VICBGCOL }
	pha				; save accu
+	lda slot_d010 + COUNT+1		; load xhigh for irq start at that slot
	sta $D010			; set xhigh for this irq
.adrend
MUXIRQ_SIZE = .adrend - .adrstart
MUXIRQ_SCREEN_ADR = .adrp1 - 1 - .adrstart
} ; zone
} ; for
; Now iteration for COUNT=NR_OF_VIRTUAL_SPRITES-1-8 manually unrolled, only
; a few instructions. Must be identical to unrolled irq code!
!zone {
.COUNT=NR_OF_VIRTUAL_SPRITES-1-8
	lda sprite_sorted_y + .COUNT + 8	; load y coord
	sta $D001+(.COUNT & 7)*2		; set for hardware sprite
	lda slot_xl + .COUNT		; load xl coord
	sta $D000+(.COUNT & 7)*2		; set for hardware sprite
	lda slot_ptr + .COUNT		; load sprite pointer
	sta $07F8+(.COUNT & 7)		; set in register
	lda slot_col + .COUNT		; load color
	sta $D027+(.COUNT & 7)		; set in register
}
sprite_mux_irq_last_done
	; last irq is done, trigger preparation irq then
	+set16im $FFFE, sprite_mux_irq_prepare
	+set8im VICRASTER, SPRITE_PREPARE_RASTERLINE
	pla
!if DEBUG_TIMING { dec VICBGCOL }
	; ack and end irq
	asl $D019
	rti

sprite_mux_irq_prepare_next
	; when accu is 0 so zero bit is set, no new irq needs to be called
	; but the last one needs to end!
	bne +
	pla				; undo jsr
	pla				; undo jsr
	jmp sprite_mux_irq_last_done
+	sta VICRASTER			; set as irq trigger
	cld				; needed, as the main program can use decimal mode anywhere
	sec				; check if we are late for next irq!
	sbc #MIN_RASTER_LINES_BETWEEN_IRQS
	cmp VICRASTER
	; if C=0 we are too late for next irq, but do not start it BEFORE the
	; stored raster line or it will be too early!
	; if we are too late for the irq all displaying fails from here on
	bcs sprite_mux_irq_done		; if carry set, VICRASTER <= next_rasterline - 2, so end IRQ
	adc #(MIN_RASTER_LINES_BETWEEN_IRQS-1)	; C=0, prepare check VICRASTER <= next_rasterline - 1
!if DEBUG_TIMING { inc VICBGCOL }
-	cmp VICRASTER			; as long as we are in line before, do busy waiting
	bcs -
!if DEBUG_TIMING { dec VICBGCOL }
	rts				; return to unrolled code to continue irq.
sprite_mux_irq_done			; set up next irq vector from saved address and end irq
	pla
	clc
	adc #3
	sta $FFFE	; need to add 1 to address, because of the way JSR works, +2 to skip the bcc.
	pla
	adc #0
	sta $FFFF
	pla		; restore accu
	asl $D019	; ack irq
!if DEBUG_TIMING { dec VICBGCOL }
	rti
sprite_mux_irq_code_end

} ; if UNROLL_FULL_IRQ

