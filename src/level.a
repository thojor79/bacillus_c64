; Bacillus_c64
; Copyright (C) 2016-2017  Thorsten Jordan.
; 
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ***************************************************************************************
;
; all code related to playing a level
;
; ***************************************************************************************

SCORE_LINE_Y = 243

run_level
; setup VIC bitmap multicolor mode
	+set8im VICCTRL1, $0B	; Bitmap mode off, display off
	lda #$13		; Bit 4: Multicolor on, Bit 3:0 38 Column mode, Bits 0-2: offset left border (4 neutral, so 7-4=3)
	sta VICCTRL2
	sta vicctrl2_scrolling

; clear temporary data in zeropage etc.
	lda #0
	ldx #(temp_data_end - temp_data_begin)
-	sta temp_data_begin-1,x
	dex
	bne -

; set initial screen_pos - it is NOT 0,0 and influences scrolling and VICMEMCTRL!
	+set8im screen_pos_x, $40	; Pixel Offset 4 (neutral position)

; set initial buffer addresses
	lda #>SCREEN1
        sta backframebuffer_adrmsb
        lda #>SCREEN0
        sta visibleframebuffer_adrmsb
        sta renderframebuffer_adrmsb

; sprite multicolor off for all sprites
	+set8im $D01C, 0	; disable multicolor for all sprites

; set the visible frame buffer to default (screen 0)
	jsr setvisibleframebuffer

; spawn the player actor
	+set8im TEMP2, 0	; start address - fixme later level specific!
	+set8im TEMP3, 11
	jsr spawn_player

; fill visible screen with tiles of level
; Note! This sets sprite registers like color and multicolor flag.
; either write from renderer to spawn buffer and run that later,
; so spawn routine doesnt need to save registers or blend_in needs
; to read and backup mc register and colors (9 byte)
	jsr render_tiles_on_screen

; Set up score panel - only to screen0 !
	ldx #40
-	lda scorepanelchars-1,x
	sta SCREEN0+24*40-1,x
	sta SCREEN1+24*40-1,x
	lda #0
	sta COLORRAM+24*40-1,x
	dex
	bne -

; render score panel once
	jsr update_score_panel

; Set up sprite based blend in effect (also sets up a raster irq!)
	jsr blend_in_init

; turn display on
	+set8im VICCTRL1, $1B

; Handle blend in effect
	jsr blend_in_do

; set normal raster irq for status bar
	sei
	+set16im $FFFE, rasterirq_scoreline
	+set8im VICRASTER, SCORE_LINE_Y-2
	cli

; prepare rest of sprite registers
	; All sprites before characters
	+set8im $D01B, 0
	; All sprites double size off
	;lda #0		; double size off - A already 0!
	sta $D017	; double size y
	sta $D01D	; double size x
	; All sprites enable
	+set8im VICSPRITEENABLE, $FF

; --------------------------------------- main loop of a level
mainloop
	; wait until raster line is at bottom of foreground screen
-	lda VICRASTER
	cmp #251	; end of visible screen
	bcc -
	; first handle animation of characters, not so critical, but fast, must be done before color ram copy!
	jsr compute_char_animations
	; write actor positions to sprite data, rather critical, do this before color ram copy! it is very fast.
	jsr update_actors
	; check if scrolling must be handled and do the scrolling! very critical with color ram copy!
	jsr handle_scrolling
	;
	; not so time critical tasks to be done every frame
	;
	jsr check_actor_collisions
	; Read joystick positions and handle input
	jsr check_joy2_state
	; Actor 0 is player and has special movement
	jsr player_control_joy2
	; Handle all actor movements, walk/jump/fall/kill
	jsr handle_actor_movement
	; handle killed enemies or player
	jsr handle_dead_actors
	; change actor shapes
	jsr compute_actor_animations
	; handle the AI for actor movement
	jsr handle_actor_behaviour
	; increment frame counter
	inc framecounter
	; cycle raster bar colors
	jsr cycle_score_panel_colors
	; render current score to score panel
	jsr update_score_panel
	; check if player is at end of level
	lda actor_xh
	cmp #$FF
	beq end_level
	; check if lives are 0 (player dead)
+	lda lives
	bne mainloop
	; as long as actor_dead_anim_phase is not null, continue as well
	lda actor_dead_anim_phase
	bne mainloop
	; handle game over
	jmp game_over
end_level
	; show blend out effect
	;fixme
	; disable all sprites
	+set8im VICSPRITEENABLE, 0
	; return to main game loop
	rts
; -------------- end of main loop

game_over
	+set8im VICBGCOL, 0
	jsr update_score_panel
	; show "Game over" message with sprites!
	; Set sprite pointers
	ldx #8
-	lda game_over_sprite_ptr-1,x
	sta SCREEN0+$03F8-1,x
	sta SCREEN1+$03F8-1,x
	dex
	bne -
	; Set hires, double sized, multicolor disabled
	lda #$FF
	sta $D017
	sta $D01D
	lda #$00
	sta $D01C
	; Set positions
	lda #79	; Y
!for COUNT, 0, 3 {
	sta $D001 + COUNT * 2
}
	lda #179
!for COUNT, 0, 3 {
	sta $D001 + (COUNT + 4) * 2
}
	; X
!for COUNT, 0, 3 {
	lda game_over_sprite_x + COUNT
	sta $D000 + COUNT * 2
	sta $D000 + (COUNT + 4) * 2
}
	lda game_over_sprite_x+4
	sta $D010
	; Cycle colors between greys and still cycle score panel
	+set8im framecounter, 0
game_over_next_frame
-	lda VICRASTER
	cmp #251	; end of visible screen and close to wrap so only triggered once per frame
	bcc -
	jsr cycle_score_panel_colors
	inc framecounter
	lda framecounter
	lsr
	lsr
	and #15
	tax
	lda intro_text_colors,x
!for COUNT, 0, 7 {
	sta $D027 + COUNT
}
	; wait until raster line is > 255
-	lda VICRASTER
	bmi -
	; Wait for joystick button here - but not during the first 2-3 seconds,
	; to avoid clicks still done by player to quickly move away game over
	; message. not yet implemented, fixme
	lda CIA1_DATAPORT_A
	and #$10
	bne game_over_next_frame	; only wait for press yet
	; disable all sprites
	+set8im VICSPRITEENABLE, 0
	rts

; ----------------------- show score in score panel
; Uses	A, X
update_score_panel
	lda score
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+38
	sta SCREEN1+24*40+38
	lda score
	lsr
	lsr
	lsr
	lsr
	sec
	adc #SCPO
	sta SCREEN0+24*40+37
	sta SCREEN1+24*40+37
	lda score+1
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+36
	sta SCREEN1+24*40+36
	lda score+1
	lsr
	lsr
	lsr
	lsr
	sec
	adc #SCPO
	sta SCREEN0+24*40+35
	sta SCREEN1+24*40+35
	lda score+2
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+34
	sta SCREEN1+24*40+34
	; lives
	lda lives
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+9
	sta SCREEN1+24*40+9
	lda lives
	lsr
	lsr
	lsr
	lsr
	sec
	adc #SCPO
	sta SCREEN0+24*40+8
	sta SCREEN1+24*40+8
	rts

; ----------------------- cycle raster bar colors for score panel -----------------
; Uses	A, X, Y
cycle_score_panel_colors
	lda framecounter
	and #3
	bne ++
	ldy rasterbar_colors
	ldx #0
-	lda rasterbar_colors+1,x
	sta rasterbar_colors+0,x
	inx
	cpx #6
	bne -
	sty rasterbar_colors+6
++	rts

; ----------------------- animate characters ----------------
compute_char_animations
	; Handle background animation
	inc background_animation_phase
	lda background_animation_phase	; 32 phases - something is still a bit wrong
	lsr	; only every 2nd frame
	and #31
	; Phase is now in Accu, 0-31. We have 16 bytes per phase. So multiply phase
	; by 16 and compute read address, then copy 16 bytes from there.
	; shift 4 bytes, then leftmost bit is in carry
	asl
	asl
	asl
	asl
	sta compute_char_animations_adr0+1
	lda #>bganimation_data0	; must be 256 byte aligned...
	adc #0
	sta compute_char_animations_adr0+2
	ldx #0
compute_char_animations_adr0
	lda bganimation_data0,x
	sta VICCHARSET+$10*8,x	; fixme char index and count and phases is hardcoded, depends on level
	inx
	cpx #16
	bne compute_char_animations_adr0
	rts

; ----------------- Check if tile is blocker ---------
; Input	TEMP0,TEMP1 x,y offset in level data
; Uses	A
; Output	Carry-Bit if blocker
check_if_tile_is_ground
	lda #>LEVEL_DATA
	clc
	adc TEMP1
	sta check_tile_adr+2
	lda TEMP0
	sta check_tile_adr+1
check_tile_adr
	lda LEVEL_DATA
	cmp #8		; all tiles from no.8 on
	rts

; ----------------------------------- Interrupt routine for score line drawing
rasterirq_scoreline
	pha
	txa
	pha
	tya	; this IRQ doesn't change Y register, so we don't need to save it
		; - beware jmp-address would be different as well, is also set by
		; blend_in_do before rts there!
	pha
; We disabled all IRQ sources, so we only have raster IRQs here!
;	lda $D019		; check if IRQ was from raster line
;	bmi dorasterirq		; Bit 7 set: raster IRQ was interrupt reason
;	lda $DC0D		; ACK other irq
;	cli			; enable IRQs
;	jmp $EA31		; jump to system IRQ handler
; Note that if we would disable kernal rom as well, system would directly jump
; to our interrupt handler which means 2-9 cycles after raster line occours.
; Register storing needs to be done then anyway. Additional 14 cycles (ca.)
; Are used in kernal to check for BRK flag, which we don't have.
; we don't use kernal anymore, so some cycles are saved.
	; score panel reached, so raster is somewhere on or after SCORE_LINE_Y-2
	; wait for stable raster line by busy waiting
	lda #(SCORE_LINE_Y-1)	; loop until raster line is <= SCORE_LINE_Y-1, so < SCORE_LINE_Y
-	cmp VICRASTER
	bcs -
	; We are now stable in SCORE_LINE_Y
	; set first background color already, so it is stable
	+copy8 VICFGCOL, rasterbar_colors
	; Set scroll to neutral for score panel
	; Note that this command seems to delay current raster line...
	+set8im VICCTRL2, $10
	; Now wait for next raster lines and set color then
!for COUNT, 0, 7 {
	ldx rasterbar_colors+COUNT
	lda #(SCORE_LINE_Y+COUNT)
-	cmp VICRASTER
	bcs -
	stx VICFGCOL
}
	; We are now in line 251, below visible screen.
	; restore scroll register
	+copy8 VICCTRL2, vicctrl2_scrolling
	; done for this interrupt - for blendin special code would follow,
	; so blend_in overwrites the jump address and restores it later
rasterirq_scoreline_end
	jmp rasterirq_ack_and_end

; ----------------------- prepare read level data from raw data
; Uses	TEMPADR0, TEMPADR1, A, X, Y and :
;	TEMP0 - row counter
;	TEMP1 - row counter with bit 0 cleared
;	TEMP2 - subtile index 0...3
;	TEMP3 - index in pseudo random table 0..15 generated by position
;	TEMP4 - subtile index 0...1 for column
; raw data has values 0-x for different types.
; Tiles are 1x1, 2x1 and 2x2. Within a category select a pseudo random tile.
; Randomness depends on position.
; For actors use table with 0...15 random values.
; Problem: for larger tiles we need to generate one random large (meta) tile and
; place it in 2 or 4 tiles. But we can't set tile data in advance because we
; can't tell from number if it is an index or a tile number when encountered
; later. Also it would be very tricky to set multiple tiles in one run.
; Solution: generate pseudo random number only from upper/left coordinate.
; This also means that 2x1 and 2x2 tiles must not start on odd columns/rows,
; Otherwise they would look broken. But that doesn't seem to be a critical
; restriction. We need to have 3 or 4 random number generations then,
; as best in a subroutine.
; 0  - background	(2x2)
; 1  - animated background	(1x1)
; 2  - enemies		(1x1)
; 3  - floor		(2x1)
; 4  - obstacleA	(2x2)
; 5  - island		(2x1)
; 6  - hole in ground	(2x1)
; 7  - bonus		(1x1)
; 8  - obstacleB	(2x1)
; We have 236 chars available (256-20 for scorepanel), that are
; 59 tiles without reuse of chars. Use e.g. 56 tiles that are 7 rows
; of 2 * 2x2 tiles. Like the 7 categories. Background and animated
; background with boni is one such row.
; so we have 7 more rows: floor, ceiling, island, obstacle A, obstacle B,
; traps (later).
; We need two different obstacles, because we need height 1 to have
; obstacles with odd height values!
; level data has already been unpacked to LEVEL_DATA. Iterate over it and replace values.
prepare_level_data
	+set16im TEMPADR0, LEVEL_DATA
	+set8im TEMP0, 0
	+set8im TEMP1, 0
	ldy #0	; column counter
prepare_level_data_next_tile
	; generate tile subcoordinate (y/x bits 0 to value 0...3)
	tya
	and #1
	sta TEMP4	; bit0 of y as subtile index for 2x1 tiles
	lsr		; bit 0 to carry
	lda TEMP0
	and #1
	rol		; rotate in carry -> now A is x0 * 2 + y0
	sta TEMP2	; store subtile index
	lda (TEMPADR0),y	; load tile type index - note if bigger than table, game will crash!
	; replace index with tile number
	; jump to code handling specific tile by index (switch command)
	tax
	lda prepare_level_jump_table_lo,x
	sta TEMPADR1
	sta prepare_level_data_case+1
	lda prepare_level_jump_table_hi,x
	sta TEMPADR1+1
	sta prepare_level_data_case+2
	lda (TEMPADR0),y
prepare_level_data_case
	jsr prepare_level_data_tile0
	sta (TEMPADR0),y	; store final tile number that is in Accu
	iny			; next column
	bne prepare_level_data_next_tile
	inc TEMPADR0+1		; next row, Y is already 0 here!
	inc TEMP0
	lda TEMP0
	and #$FE
	sta TEMP1
	lda TEMP0
	cmp #TILESYPERSCREEN
	bne prepare_level_data_next_tile
	rts
; Uses TEMP3, expects row to be in TEMP0 register, column in Y register
generate_random_index_1x1
	; combine 4 bits of x with 2 nibbles of y for a index 0...15 where
	; you read from a pseudo random table containing values 0...7 (3 bits)
	tya
	lsr
	lsr
	lsr
	lsr
	sta TEMP3
	tya
	eor TEMP3
	eor TEMP0
	and #$0F
	rts
; Uses TEMP3, expects row to be in TEMP0 register, column in Y register
generate_random_index_2x1
	; combine 4 bits of x with 2 nibbles of y for a index 0...15 where
	; you read from a pseudo random table containing values 0...7 (3 bits)
	tya
	lsr
	lsr
	lsr
	lsr
	sta TEMP3
	tya
	and #$FE	; clear bit 0 of y!
	eor TEMP3
	eor TEMP0
	and #$0F
	rts
; Uses TEMP3, expects row to be in TEMP0 register, column in Y register
generate_random_index_2x2
	; combine 4 bits of x with 2 nibbles of y for a index 0...15 where
	; you read from a pseudo random table containing values 0...7 (3 bits)
	tya
	lsr
	lsr
	lsr
	lsr
	sta TEMP3
	tya
	and #$FE	; clear bit 0 of y!
	eor TEMP3
	eor TEMP1
	and #$0F
	rts
prepare_level_data_tile0	; background tiles 0...3 as 2x2 metatile
	lda TEMP2		; use subtile index as tilenumber
	rts
prepare_level_data_tile1	; animated background tile 4
	lda #4			; always same tilenumber
	rts
prepare_level_data_tile2	; enemies
	jsr generate_random_index_1x1
        tax
        lda pseudo_rand_table_16,x
	asl
	asl
	asl
	ora #$80
	ora TEMP2
	rts
prepare_level_data_tile3	; floor tiles 8,9 or 10,11 or 12,13 as 2x1 metatile
	jsr generate_random_index_2x1
	tax
	lda pseudo_rand_table_3,x
	asl			; multiply by 2, then carry clear
	adc #8
	rts
prepare_level_data_tile4	; obstacle A 2x2 metatile index 16-19
	lda TEMP2
	clc
	adc #16
	rts
prepare_level_data_tile5	; island 2x1 sized, 24,25 or 26,27
	jsr generate_random_index_2x1
	tax
	lda pseudo_rand_table_16,x
	and #2
	clc
	adc #24
	adc TEMP4
	rts
prepare_level_data_tile6	; floor hole tile 14,15
	lda TEMP4
	clc
	adc #14
	rts
prepare_level_data_tile7	; bonus tiles 5,6,7 as 1x1 sized tile
	jsr generate_random_index_1x1
	tax
	lda pseudo_rand_table_3,x
	clc
	adc #5
	rts
prepare_level_data_tile8	; obstacle B metatile 2x1 index 20,21 or 22,23
	jsr generate_random_index_2x1
	tax
	lda pseudo_rand_table_16,x
	and #2
	clc
	adc #20
	adc TEMP4
	rts

; ------------ data

pseudo_rand_table_3
!byte 2,0,1, 0,1,2, 1,2,0, 2,1,0, 0,2,1, 1,0,2, 1

pseudo_rand_table_8
!byte 3,4,7,0,2,6,1,5, 6,4,1,7,5,2,3,0

pseudo_rand_table_16
!byte 13,7,5,8,0,12,4,9,15,2,6,3,10,1,14

prepare_level_jump_table_lo
!byte <prepare_level_data_tile0
!byte <prepare_level_data_tile1
!byte <prepare_level_data_tile2
!byte <prepare_level_data_tile3
!byte <prepare_level_data_tile4
!byte <prepare_level_data_tile5
!byte <prepare_level_data_tile6
!byte <prepare_level_data_tile7
!byte <prepare_level_data_tile8

prepare_level_jump_table_hi
!byte >prepare_level_data_tile0
!byte >prepare_level_data_tile1
!byte >prepare_level_data_tile2
!byte >prepare_level_data_tile3
!byte >prepare_level_data_tile4
!byte >prepare_level_data_tile5
!byte >prepare_level_data_tile6
!byte >prepare_level_data_tile7
!byte >prepare_level_data_tile8

rasterbar_colors
!byte 6,14,13,1,13,14,6, 9	; fixme: the last number is only valid for cheese levels! needs to be level specific
; read and copy it from register? or store in extra lookup var when it is set?

game_over_sprite_ptr
!byte 64+6, 64+0, 64+12, 64+4, 64+14, 64+21, 64+4, 64+17

game_over_sprite_x
!byte 64, 128, 192, 0, $88

scorepanelchars
!byte  0+SCPO,16+SCPO,18+SCPO,17+SCPO,15+SCPO,11+SCPO,19+SCPO, 0+SCPO
!byte  1+SCPO, 4+SCPO, 0+SCPO, 0+SCPO, 0+SCPO, 0+SCPO,16+SCPO,15+SCPO
!byte 17+SCPO,15+SCPO,16+SCPO,19+SCPO, 0+SCPO, 1+SCPO, 2+SCPO, 0+SCPO
!byte  0+SCPO, 0+SCPO, 0+SCPO,11+SCPO,12+SCPO,13+SCPO,14+SCPO,15+SCPO
!byte 19+SCPO, 0+SCPO, 3+SCPO, 4+SCPO, 5+SCPO, 6+SCPO, 7+SCPO, 0+SCPO
