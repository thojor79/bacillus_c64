; Bacillus_c64
; Copyright (C) 2016-2017  Thorsten Jordan.
; 
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ***************************************************************************************
;
; all code related to playing a level
;
; ***************************************************************************************

SCORE_LINE_Y = 243

run_level
; setup VIC bitmap multicolor mode
	+set8im VICCTRL1, $0B	; Bitmap mode off, display off
	lda #$13		; Bit 4: Multicolor on, Bit 3:0 38 Column mode, Bits 0-2: offset left border (4 neutral, so 7-4=3)
	sta VICCTRL2
	sta vicctrl2_scrolling

; clear temporary data in zeropage etc.
	lda #0
	ldx #(temp_data_end - temp_data_begin)
-	sta temp_data_begin-1,x
	dex
	bne -

; set initial screen_pos - it is NOT 0,0 and influences scrolling and VICMEMCTRL!
	+set8im screen_pos_x, $40	; Pixel Offset 4 (neutral position)

; sprite multicolor off for all sprites
	+set8im $D01C, 0	; disable multicolor for all sprites

; set the visible frame buffer to default (screen 0)
	jsr setvisibleframebuffer

; fill visible screen with tiles of level
; Note! This sets sprite registers like color and multicolor flag.
; either write from renderer to spawn buffer and run that later,
; so spawn routine doesnt need to save registers or blend_in needs
; to read and backup mc register and colors (9 byte)
	jsr render_tiles_on_screen

; Set up score panel - only to screen0 !
	ldx #40
-	lda scorepanelchars-1,x
	sta SCREEN0+24*40-1,x
	lda #0
	sta COLORRAM+24*40-1,x
	dex
	bne -

; render score panel once
	jsr update_score_panel

; Set up sprite based blend in effect (also sets up a raster irq!)
	jsr blend_in_init

; turn display on
	+set8im VICCTRL1, $1B

; Handle blend in effect
	jsr blend_in_do

; set normal raster irq for status bar
	sei
	+set16im $FFFE, rasterirq_scoreline
	+set8im VICRASTER, SCORE_LINE_Y-2
	cli

; prepare rest of sprite registers
	; All sprites before characters
	+set8im $D01B, 0
	; All sprites double size off
	;lda #0		; double size off - A already 0!
	sta $D017	; double size y
	sta $D01D	; double size x
	; All sprites enable
	+set8im VICSPRITEENABLE, $FF

; --------------------------------------- main loop of a level
mainloop
	; wait until raster line is at bottom of foreground screen
-	lda VICRASTER
	cmp #251	; end of visible screen
	bcc -
	; first handle animation of characters, not so critical, but fast, must be done before color ram copy!
	jsr compute_char_animations
	; write actor positions to sprite data, rather critical, do this before color ram copy! it is very fast.
	jsr update_actors
	; check if scrolling must be handled and do the scrolling! very critical with color ram copy!
	jsr handle_scrolling
	;
	; not so time critical tasks to be done every frame
	;
	jsr check_actor_collisions
	; Read joystick positions and handle input
	jsr check_joy2_state
	; Actor 0 is player and has special movement
	jsr player_control_joy2
	; Handle all actor movements, walk/jump/fall/kill
	jsr handle_actor_movement
	; handle killed enemies or player
	jsr handle_dead_actors
	; change actor shapes
	jsr compute_actor_animations
	; handle the AI for actor movement
	jsr handle_actor_behaviour
	; increment frame counter
	inc framecounter
	; cycle raster bar colors
	jsr cycle_score_panel_colors
	; render current score to score panel
	jsr update_score_panel
	; check if player is at end of level
	lda actor_xh
	cmp #$FF
	beq end_level
	; check if lives are 0 (player dead)
+	lda lives
	bne mainloop
	; as long as actor_dead_anim_phase is not null, continue as well
	lda actor_dead_anim_phase
	bne mainloop
	; handle game over
	jmp game_over
end_level
	; show blend out effect
	;fixme
	; disable all sprites
	+set8im VICSPRITEENABLE, 0
	; return to main game loop
	rts
; -------------- end of main loop

game_over
	+set8im VICBGCOL, 0
	jsr update_score_panel
	; show "Game over" message with sprites!
	; Set sprite pointers
	ldx #8
-	lda game_over_sprite_ptr-1,x
	sta SCREEN0+$03F8-1,x
	sta SCREEN1+$03F8-1,x
	dex
	bne -
	; Set hires, double sized, multicolor disabled
	lda #$FF
	sta $D017
	sta $D01D
	lda #$00
	sta $D01C
	; Set positions
	lda #79	; Y
!for COUNT, 0, 3 {
	sta $D001 + COUNT * 2
}
	lda #179
!for COUNT, 0, 3 {
	sta $D001 + (COUNT + 4) * 2
}
	; X
!for COUNT, 0, 3 {
	lda game_over_sprite_x + COUNT
	sta $D000 + COUNT * 2
	sta $D000 + (COUNT + 4) * 2
}
	lda game_over_sprite_x+4
	sta $D010
	; Cycle colors between greys and still cycle score panel
	+set8im framecounter, 0
game_over_next_frame
-	lda VICRASTER
	cmp #251	; end of visible screen and close to wrap so only triggered once per frame
	bcc -
	jsr cycle_score_panel_colors
	inc framecounter
	lda framecounter
	lsr
	lsr
	and #15
	tax
	lda intro_text_colors,x
!for COUNT, 0, 7 {
	sta $D027 + COUNT
}
	; wait until raster line is > 255
-	lda VICRASTER
	bmi -
	; Wait for joystick button here - but not during the first 2-3 seconds,
	; to avoid clicks still done by player to quickly move away game over
	; message. not yet implemented, fixme
	lda CIA1_DATAPORT_A
	and #$10
	bne game_over_next_frame	; only wait for press yet
	; disable all sprites
	+set8im VICSPRITEENABLE, 0
	rts

; ----------------------- show score in score panel
; Uses	A, X
update_score_panel
	lda score
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+38
	lda score
	lsr
	lsr
	lsr
	lsr
	sec
	adc #SCPO
	sta SCREEN0+24*40+37
	lda score+1
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+36
	lda score+1
	lsr
	lsr
	lsr
	lsr
	sec
	adc #SCPO
	sta SCREEN0+24*40+35
	lda score+2
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+34
	; lives
	lda lives
	and #$0F
	sec
	adc #SCPO
	sta SCREEN0+24*40+9
	lda lives
	lsr
	lsr
	lsr
	lsr
	sec
	adc #SCPO
	sta SCREEN0+24*40+8
	rts

; ----------------------- cycle raster bar colors for score panel -----------------
; Uses	A, X, Y
cycle_score_panel_colors
	lda framecounter
	and #3
	bne ++
	ldy rasterbar_colors
	ldx #0
-	lda rasterbar_colors+1,x
	sta rasterbar_colors+0,x
	inx
	cpx #6
	bne -
	sty rasterbar_colors+6
++	rts

; ----------------------- animate characters ----------------
compute_char_animations
	; Handle background animation
	inc background_animation_phase
	lda background_animation_phase	; 32 phases - something is still a bit wrong
	lsr	; only every 2nd frame
	and #31
	; Phase is now in Accu, 0-31. We have 16 bytes per phase. So multiply phase
	; by 16 and compute read address, then copy 16 bytes from there.
	; shift 4 bytes, then leftmost bit is in carry
	asl
	asl
	asl
	asl
	sta compute_char_animations_adr0+1
	lda #>bganimation_data0	; must be 256 byte aligned...
	adc #0
	sta compute_char_animations_adr0+2
	ldx #0
compute_char_animations_adr0
	lda bganimation_data0,x
	sta VICCHARSET+$10*8,x	; fixme char index and count and phases is hardcoded, depends on level
	inx
	cpx #16
	bne compute_char_animations_adr0
	rts

; ----------------- Check if tile is blocker ---------
; Input	TEMP0,TEMP1 x,y offset in level data
; Uses	A
; Output	Carry-Bit if blocker
check_if_tile_is_ground
	lda #>LEVEL_DATA
	clc
	adc TEMP1
	sta check_tile_adr+2
	lda TEMP0
	sta check_tile_adr+1
check_tile_adr
	lda LEVEL_DATA
	cmp #8		; all tiles from no.8 on
	rts

; ----------------------------------- Interrupt routine for score line drawing
rasterirq_scoreline
	pha
	txa
	pha
	tya	; this IRQ doesn't change Y register, so we don't need to save it
		; - beware jmp-address would be different as well, is also set by
		; blend_in_do before rts there!
	pha
; We disabled all IRQ sources, so we only have raster IRQs here!
;	lda $D019		; check if IRQ was from raster line
;	bmi dorasterirq		; Bit 7 set: raster IRQ was interrupt reason
;	lda $DC0D		; ACK other irq
;	cli			; enable IRQs
;	jmp $EA31		; jump to system IRQ handler
; Note that if we would disable kernal rom as well, system would directly jump
; to our interrupt handler which means 2-9 cycles after raster line occours.
; Register storing needs to be done then anyway. Additional 14 cycles (ca.)
; Are used in kernal to check for BRK flag, which we don't have.
; we don't use kernal anymore, so some cycles are saved.
	; score panel reached, so raster is somewhere on or after SCORE_LINE_Y-2
	; as first set VIC memory control, so new charset is used before
	; badline at raster line 243 triggers read of that address register!
	+set8im VICMEMCTRL, SCREEN0POSITION*16+VICCHARSETBLOCK_SCORELINE*2+1 	; set SCREEN0 and charset at last position
	; wait for stable raster line by busy waiting
	lda #(SCORE_LINE_Y-1)	; loop until raster line is <= SCORE_LINE_Y-1, so < SCORE_LINE_Y
-	cmp VICRASTER
	bcs -
	; We are now stable in SCORE_LINE_Y
	; set first background color already, so it is stable
	+copy8 VICFGCOL, rasterbar_colors
	; Set scroll to neutral for score panel
	; Note that this command seems to delay current raster line...
	+set8im VICCTRL2, $10
	; Now wait for next raster lines and set color then
!for COUNT, 0, 7 {
	ldx rasterbar_colors+COUNT
	lda #(SCORE_LINE_Y+COUNT)
-	cmp VICRASTER
	bcs -
	stx VICFGCOL
}
	; We are now in line 251, below visible screen.
	; restore scroll register
	+copy8 VICCTRL2, vicctrl2_scrolling
	+copy8 VICMEMCTRL, vicmemctrl_scrolling
	; done for this interrupt - for blendin special code would follow,
	; so blend_in overwrites the jump address and restores it later
rasterirq_scoreline_end
	jmp rasterirq_ack_and_end

; ------------ data

rasterbar_colors
!byte 6,14,13,1,13,14,6, 9

game_over_sprite_ptr
!byte 64+6, 64+0, 64+12, 64+4, 64+14, 64+21, 64+4, 64+17

game_over_sprite_x
!byte 64, 128, 192, 0, $88

scorepanelchars
!byte  0+SCPO,16+SCPO,18+SCPO,17+SCPO,15+SCPO,11+SCPO,19+SCPO, 0+SCPO
!byte  1+SCPO, 4+SCPO, 0+SCPO, 0+SCPO, 0+SCPO, 0+SCPO,16+SCPO,15+SCPO
!byte 17+SCPO,15+SCPO,16+SCPO,19+SCPO, 0+SCPO, 1+SCPO, 2+SCPO, 0+SCPO
!byte  0+SCPO, 0+SCPO, 0+SCPO,11+SCPO,12+SCPO,13+SCPO,14+SCPO,15+SCPO
!byte 19+SCPO, 0+SCPO, 3+SCPO, 4+SCPO, 5+SCPO, 6+SCPO, 7+SCPO, 0+SCPO
