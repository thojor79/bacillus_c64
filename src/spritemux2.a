; Bacillus_c64
; Copyright (C) 2016-2017  Thorsten Jordan.
; 
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ***************************************************************************************
;
;    sprite multiplexer V2.0
;
; ***************************************************************************************

NR_OF_VIRTUAL_SPRITES = 24 ; rather test 24 or less sprites, works with 44, min 2 (<8 doesn't make sense though)
MIN_SPRITE_Y = 30
MAX_SPRITE_Y = 250
SPRITE_Y_DISTANCE = 21		; This is just the sprite height.

;TESTING = 1
;DEBUG_TIMING = 1
;TEST_STATIC_POS = 1
;KERNAL_RAND_POS = 1

; fixme describe the muxer idea and all its great ideas here thoroughly, then we can release and use it!

; fixme describe full unrolling and its costs and how much it saves, but it isnt't worth the trouble

; fixme store date in zeropage or other ram, it influences the interrupt cycle time!

; We can speed up the irq exit by unrolling the rest of the handler code as
; well and by hardcoding the storage of the next irq address to $FFFE.
; Or unroll only the storage and then jmp to a handler routine, that does
; jmp ($FFFE) to go to next irq. It costs much space but will save up to
; 15 or more cycles per irq.
; We can even precompute slot_raster-3 values so we don't need to sbc in the
; irq (cld would be needed otherwise!)
; We can even have both variants to have a tradeoff between code size and irq cycles.
; If the next irq is triggered 1 raster line earlier (adc #1 instead of #2 at end of irq) we can avoid all the busy waiting.
; it has to be tested yet if the faster irq exit would just be enough to avoid the busy
; waiting stuff. if we change the foreground color we can see when the busy waiting starts, its more
; at the end of the rasterline. So just 15 cycles won't help there. This is just not avoidable.

; We need to trigger the irq earlier depending on how many sprites are set in the
; interrupt but it depends on every line and the time until then!
; so for every sprite in the irq compute the number of lines before it depending on
; the number of sprites in the irq until then and take the overall minimum of the
; values as start time. For example:
; with one sprite 2 lines earlier, with 8 sprites 5 lines earlier but only if all 8 are
; at the same line. If they are set up at later lines there is more time, so we don't
; need to trigger the irq 5 lines earlier, maybe 2 suffice.
; fixme it makes the preparation slower (more computation) ~ 6 RL, no surprise.
; The advantage for display is only minor. It will skip less sprites in certain situations
; or give less artifacts.


; The lower copy of the color ram is triggered when the raster irq is at half of screen,
; however this would interfere with the sprite raster interrupts. So check the raster line
; during game logic update and do the color ram copy in main cpu thread!



; A sprite multiplexer takes an arbitrary number of virtual sprites and maps
; it to the 8 hardware sprites. The number of virtual sprites doesn't need
; to be a multiple of 8.
; Virtual sprites are sorted by their y coordinate and then assigned to the
; 8 hardware sprites in the sorted order. Non visible virtual sprites are
; skipped, if there is a virtual sprite that would be the ninth sprite on a
; raster line it is skipped as well. Then the virtual sprites left over are
; assigned to several raster irqs that set up the hardware sprite registers.
; For 8 hardware sprites and N virtual sprites we can prove that there are
; at most N-8 irqs (without the first irq or code that sets up the first 8
; sprites at once). This would be the case if every new virtual sprite is
; just one raster line below the previous one and can not be set by the irq
; for the previous sprite because there is still some sprite displaying for
; that hardware sprite (we call it slot). This is a very rare case, normally
; the amount of irqs is much lower.
; So we have to compare the sorted y coordinates to screen boundaries,
; against slot y coordinate and to the current raster line of the
; current irq. We can use this preparation also to have real 16 or 9 bit x
; coordinates and don't need to fiddle with the clumsy $D010 register that
; stores all 9th bits of all sprites.
; So for every hardware sprite we have to write 4 bytes (y, xlow, pointer,
; color - in that order) and one write to xhigh register.
; Common sprite multiplexers write the 5 bytes needed to set up a sprite by
; reading an indexed table which takes at least 4 cycles per load (LDA
; indexed) command. This brings some overhead. Can we avoid the overhead
; without the preparation code to become too slow?
; Note that the fastest we can do in every raster irq to set up sprite data
; is to load the data of the sprite as immediate value and to store it in
; the corresponding registers. That way we can even skip the saving of x/y
; at start of irq. That are simple pairs of LDA #imm, STA D0xx. So interrupt
; has less overhead and every written byte takes only 6 cycles.
; However we would need to modify the interrupt code then to change the
; immediate values. This works but is very costly in preparation.
; If we load the values from a table from zeropage this takes 1 cycle more
; per load or 2 cycles if the table is not in zeropage.
; This makes additional 4 or 8 cycles per sprite but we don't need to modify
; the irq code any longer. The overhead of the irq call is very low then and
; the preparation time is also faster than with immediate value loading.
; The sort order of the sprites is kept between frames so sorting is fast because
; there is not much action (mostly only a few y values change order against each
; other).

; To avoid a preparation of jump tables we save the last address that IRQ was in 
; by doing a JSR out of the
; register setup routine and pull the address from stack. By flagging the end of an
; IRQ by setting the topmost bit of color value we can have unrolled code for all
; sprites. 
; That way the sprite mux IRQ doesn't need to save nor use the X/Y registers!
; For every sprite 4 bytes are written (y/x coord, pointer, color). The combined
; high bits for x are written once per IRQ before setting the individual sprite
; registers.
; With that technique each sprite IRQ is as fast as possible.
; Note that the first 8 sprites can be set directly after preparation and don't need
; an interrupt.

; Note! with 8 sprites we don't see first, with 1 sprite it runs amok.
; However we always have > 8 and disable invisible virtual sprites with y=255!

; note charset blends over sprite data for test from sprite 30 on

; Note distances between sprites must be > 21 or so to avoid artefacts
; with 24 it is better - we have that now



!if TESTING {
TEMP0 = 2
TEMP1 = 3
TEMP2 = 4
TEMP3 = 5
TEMP4 = 6
TEMP5 = 7
TEMPADR0 = 8
TEMPADR1 = 10
VICBGCOL = $D020
VICFGCOL = $D021
VICCTRL2 = $D016
VICMEMCTRL = $D018
VICCTRL1 = $D011
VICRASTER = $D012
VICIRQMASK = $D01A
VICSPRITEENABLE = $D015
CIA1_ICR = $DC0D

!to "test/spritemux2.prg", cbm

!src "src/macros.a"

*= $0801	; Program start at 2049

; Basic start code 1979 SYS2066:REM TJ
!byte $10,$08,$BB,$07,$9E,$32,$30,$36,$36,$3A,$8F,$20,$54,$4A,$00,$00,$00

main
	jmp +
; for easier debugging
!byte <vsprite_y
!byte >vsprite_y
!byte <(sprite_mux_irq_code_end-sprite_mux_irq)
!byte >(sprite_mux_irq_code_end-sprite_mux_irq)
!byte <MUXIRQ_SIZE
!byte >MUXIRQ_SIZE
+
	; Set position and move values with randomness from kernal code
	; Positions
!if KERNAL_RAND_POS {
	ldx #NR_OF_VIRTUAL_SPRITES-1
main_prep_pos_dxy
	lda $E000,x
	sta vsprite_xl,x
	lda $E018,x
	and #1
	sta vsprite_xh,x
	lda $E030,x
	sta vsprite_y,x
	; Deltas
	lda $E048,x
	and #3
	clc
	adc #1
	sta vsprite_dx,x
	lda $E060,x
	and #1
	clc
	adc #1
	sta vsprite_dy,x
	dex
	bpl main_prep_pos_dxy
}
	; Set up generic IRQ handling (only raster irqs)
	sei
	+set8im VICRASTER, 0
	+set8im VICCTRL1, $1B	; clear 9th bit of raster line selector, set mc mode
	+set8im VICIRQMASK, $01	; Set only raster as source for IRQ of VIC (default $F0)
	lda #$7F		; disable timer IRQs
	sta CIA1_ICR
	lda CIA1_ICR		; ack CIA irq
	asl $D019		; Acknowledge possible pending raster irq
	+set8im 1, $35		; only I/O, no kernal
	jsr sprite_mux_init
	; wait for raster at bottom
--	lda #251
-	cmp VICRASTER
	bcs -
	jsr sprite_mux_prepare  ; sorting works
!if DEBUG_TIMING {
	+set8im VICBGCOL, 14
}
!if TEST_STATIC_POS {
	jmp --
}
	; increment x/y and repeat.
	ldx #NR_OF_VIRTUAL_SPRITES-1
-	lda vsprite_xl,x
	clc
	adc vsprite_dx,x
	sta vsprite_xl,x
	lda vsprite_xh,x
	adc #0
	sta vsprite_xh,x
	beq +
	lda vsprite_xl,x
	cmp #80
	bcc +
	; x >= 336, set to 24
	dec vsprite_xh,x
	lda #24
	sta vsprite_xl,x
+
	lda vsprite_y,x
	clc
	adc vsprite_dy,x
	; avoid $FF as value! that is end marker - would kill displaying
	cmp #$FF
	bne +
	lda #0
+
	sta vsprite_y,x
	dex
	bpl -
	; next frame
	jmp --

!src "sprites32_sprdata.a"	; sprites32_data

vsprite_dx
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!byte (((COUNT * 789) % 3) + 1)
}

vsprite_dy
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!byte ((COUNT * 337) & 1) + 1
}

}

vsprite_y
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte <(50 + 3*COUNT)	; *5
		;!byte <((COUNT / 8) * 3 + (COUNT % 8) * 13 + 50)
	} else {
		!byte 0
	}
}
!byte 255	; y value to use as end marker (saves extra check in preparation loop!)

vsprite_xl
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte <(24 + (COUNT % 8) * 30 + (COUNT / 8) * 10)
	} else {
		!byte 0
	}
}

vsprite_xh
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte >(24 + (COUNT % 8) * 30 + (COUNT / 8) * 10)
	} else {
		!byte 0
	}
}

vsprite_ptr
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte (sprites32_data/64+COUNT)
	} else {
		!byte 0	
	}
}

vsprite_col
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-1 {
	!if TESTING {
		!byte ((COUNT % 15) + 7) & 15
	} else {
		!byte 0
	}
}

bit_nand_table
!for BIT, 0, NR_OF_VIRTUAL_SPRITES-8-1 {
!byte 255-(1<<(BIT&7))
}

bit_or_table
!for BIT, 0, NR_OF_VIRTUAL_SPRITES-8-1 {
!byte (1<<(BIT&7))
}

; Cycles needed for IRQ: 6-9 for IRQ itself, then pha/lda/sta=3+3+4=10
; every block takes: (3+4)*4+3=31 if the bpl is taken.
; This means cycles we need for N sprites:
; N	Cycles
; 1	41
; 2	72
; 3	103
; 4	134
; 5	165
; 6	196
; 7	227
; 8	258
; Worst case is one badline (22 cycles) and several normal lines (63 cycles),
; so we have cycles:
; Lines	Cycles
; 1	22-63
; 2	85-126
; 3	148-189
; 4	211-252
; 5	274-315
; Thus to be sure to display all sprites it takes worst case:
; N	Lines
; 1	1-2, rather 1, but at least 2!
; 2	2
; 3	2-3, rather 2
; 4	3
; 5	3-4, rather 3
; 6	4
; 7	4-5, rather 4
; 8	5
sprite_mux_irq_lines_before_sprite
!byte 2,2,2,3,3,4,4,5

; space needed: NR_VIRT for sort order, NR_V for sprite_sorted_y,
; (NR_V-8)*5 for the other values, so in total NR_V*7-5*8.
; For 32 sprites this would be 184 bytes of zeropage,
; for 24 sprites this would be 128 bytes of zeropage, thats ok.
; use one extra byte in sprite_sort_order as end marker to save one additional stop check in preparation loop!
; This saves 6*16=96 cycles in preparation loop at the cost of only 1 zeropage byte and 1 byte ram, seems good
sprite_sort_order = 64-1		; must be in zeropage because of stx xxx,y
; Note! The following data doesn't need to be in zeropage, but it is faster that way
sprite_sorted_y = sprite_sort_order + NR_OF_VIRTUAL_SPRITES + 1	;$40+$18=$58, for 16
slot_d010 = sprite_sorted_y + NR_OF_VIRTUAL_SPRITES		;$58+$18=$70
slot_xl = slot_d010 + NR_OF_VIRTUAL_SPRITES-8			;$80
slot_ptr = slot_xl + NR_OF_VIRTUAL_SPRITES-8			;$90
slot_col = slot_ptr + NR_OF_VIRTUAL_SPRITES-8			;$a0
slot_raster = slot_col + NR_OF_VIRTUAL_SPRITES-8		;$b0


; Prepare the sprite multiplexer
sprite_mux_init
	; turn on all sprites
	+set8im VICSPRITEENABLE, $FF
	; prepare any initial sort order - must be in zeropage!
	ldy #NR_OF_VIRTUAL_SPRITES	; one more to also set sort index for stop marker!
-	tya
	sta sprite_sort_order,y
	dey
	bpl -
	; set up irq
	sei
	+set16im $FFFE, sprite_mux_irq_dummy
	+set8im VICRASTER, 0
	cli
	rts

; *************************************************************
; Routine to prepare next frame's sprite data
; *************************************************************
; sorts sprite indices by the sprite's y coordinate
; and prepares interrupt data (needs to be called while raster is not in
; visible area of screen!
; USES	TEMP0,TEMP1,TEMP2,TEMP3,TEMP4,A,X,Y
SPRITE_MUX_XHVAL = TEMP0
SPRITE_MUX_SORT_INDEX = TEMP3	; index in sorted table
SPRITE_MUX_NRSPRINIRQ = TEMP1	; uses one byte, nr of sprites in current irq
SPRITE_MUX_CURRENT_RL = TEMP2	; uses one byte, current rasterline for irq
SLOT_NR_IRQ_BEGIN = TEMP4
; ************************************************************
sprite_mux_prepare
!if DEBUG_TIMING {
	inc VICBGCOL
}
	; as first sort indices so that sprite y coordinates are ascending with
	; insertion sort
	; outer counter of insertion sort loop is stored in y/TEMP0, going from 1 to
	; NR_OF_VIRTUAL_SPRITES-1. Inner counter is y register.
	; The virtual sprite number is in x register.
	; currently processed vsprite index in TEMP1, it's y value in accu
	; the sorting takes many cycles even for already sorted arrays, but we can't
	; remove more commands.
	; Can we speed up this code anyhow? X and Y are needed in inner loop,
	; so we need to use zeropage for storage. Seems this is the minimum
	; version for intersion sort. Either there is a faster algorithm for nearly sorted
	; lists or it just takes that long.
	; Sorting indices in reverse order to save the cpy call in the outer loop would
	; save at least that call, but that saves only ~3*24 cycles (1 rasterline) total.
	ldy #1			; outer counter 1...NR_OF_VIRTUAL_SPRITES-1
sprite_mux_sort_outerloop
	ldx sprite_sort_order,y
	lda vsprite_y,x
	sty TEMP0		; save outer counter
	stx TEMP1		; its sort_order[y], is overwritten so save it
sprite_mux_sort_innerloop	; since y>0 always we only check at end of loop
	ldx sprite_sort_order-1,y
	cmp vsprite_y,x		; compare to Y of processed index
	bcs sprite_mux_sort_innerdone
	stx sprite_sort_order,y
	dey
	bne sprite_mux_sort_innerloop
sprite_mux_sort_innerdone
	ldx TEMP1		; current index
	stx sprite_sort_order,y	; store sort_order[y]
	ldy TEMP0 		; load outer counter
	iny
	cpy #NR_OF_VIRTUAL_SPRITES
	bne sprite_mux_sort_outerloop
!if DEBUG_TIMING {
	inc VICBGCOL
}

!if 0 {
; test algorithm idea: sort only the y values and then the sort indices accordingly.
; it is ~8 raster lines faster, but how much faster is it for unsorted input?
; and some sprites are missing when it is used... no this is a follow up error of the raster line changes.
; so this solution may be a good idea!
; BIG advantage would be: the y values are already existing in sorted order afterwards!
; so we don't need to read sort order index and from that the y value when sprite muxing is done later.
; But we MUST NOT swap vsprite_y values! We would need to copy the vsprite_y to sorted_y array
; and sort that array - but the sorted_y values are not identical to the original vsprite_y values
; sorted - because some sprites may have been skipped! We would need to copy the y values first,
; which would take time again. So finally this solution shouldn't really be faster. Sadly...
; insertion sort:
; i = 1
; outer:
; val = A[i]
; j = i
; inner:
; if A[j-1] <= val then goto out
; A[j] = A[j-1]
; j--
; if j > 0 then goto inner
; out:
; A[j] = val
; ++i
; if i < len(A) goto outer
	ldy #1
outer
	tya
	tax
	lda vsprite_y,y
inner
	cmp vsprite_y-1,x
	bcs inner_done
	; expensive assign, must assign sort indices too!
	lda vsprite_y-1,x
	sta vsprite_y,x
	lda sprite_sort_order-1,x
	sta sprite_sort_order,x
	; and load a again as vsprite_y,y
	lda vsprite_y,y
	dex
	bne inner
inner_done
	sta vsprite_y,x
	iny
	cpy #NR_OF_VIRTUAL_SPRITES
	bne outer
!if DEBUG_TIMING {
	inc VICBGCOL
}
}


; next step: skip all sprites with y coords that are too low
; advance y register to first sprite index with visible sprite
; Note that we already start with Y=8 to avoid adding offset 8 later!
; Minus one because of iny before checking.
; Note that if all sprites are too low, this will completely run amok.
; But that case does never happen in practice.
	ldx #8-1
	lda #MIN_SPRITE_Y
-	ldy sprite_sort_order-8+1,x
	inx
	cmp vsprite_y,y
	bcs -

; now up to 8 sprites can be shown directly. Copy their sorted y coordinates
; to the zeropage arrays (we need them there for later lookup).
; We can set the other values directly.
; Do NOT break out when y coordinate is too high!
; Because if it is the sprite must not be used and we need to set some value
; for it so it is not displayed instead of turned off - and that is e.g. a
; high y coordinate!
; Logical consequence is: unroll the loop!
; we need to set the correct screen address later!
	+set8im SPRITE_MUX_XHVAL, 0	; prepare D010 (xh) register
sprite_mux_set_first8
!for COUNT, 0, 7 {
!zone {
.adrstart
	ldy sprite_sort_order+COUNT-8,x	; -8 because x already with offset 8.
	lda vsprite_y,y
	sta sprite_sorted_y+COUNT
	sta $D001+COUNT*2
	lda vsprite_xl,y
	sta $D000+COUNT*2
	lda vsprite_ptr,y
	sta $07F8+COUNT			; screen address needs replace later
.adrp1
	lda vsprite_col,y
	sta $D027+COUNT
	lda vsprite_xh,y
	beq +
	lda SPRITE_MUX_XHVAL
	ora #(1 << COUNT)
	sta SPRITE_MUX_XHVAL
+
.adrend
FIRST8_SCREEN_ADR = .adrp1 - .adrstart - 1
FIRST8_SIZE = .adrend - .adrstart
}
}
	lda SPRITE_MUX_XHVAL	; must be loaded again because the beq above may have been taken
	sta $D010		; save current xhigh value to register
!if DEBUG_TIMING {
	inc VICBGCOL
}

; copy data for virtual sprites 8-x to irq code!
; up to x-8 iterations:
; load ycoord of next sprite.
; if it is too large, stop irq generation, finish last irq
; compare ycoord to that of 8 sprites before (same slot)
; if ycoord is too close, sprite would be 9th sprite in a rasterline, so skip it
; otherwise sprite can be displayed, but check if in this irq or in new irq
; if new irq, finish current irq and create next (if not first)
; append data to current irq
; while appending irq data update xhvalue
; when all is done, finish last irq
; the slot number is in Y (nr of virtual hardware sprite that is used),
; it runs from 0 to NR_VIRTUAL_SPRITES - 1 and is 8 after setup of the first
; 8 hardware sprites.

	stx SPRITE_MUX_SORT_INDEX	; save current index (some virtual sprites could have been skipped!)
	lda #0				; init data for routine
	tay				; slot nr = 0 initially
	sty SLOT_NR_IRQ_BEGIN
	sta SPRITE_MUX_NRSPRINIRQ
	sta SPRITE_MUX_CURRENT_RL	; first rasterline = 0 as marker, so comparison below is always false for first irq
sprite_mux_prepare_next_vsprite
	ldx SPRITE_MUX_SORT_INDEX	; get sort order index
	lda sprite_sort_order,x		; get sort order. 
	tax				; put it in x
	lda vsprite_y,x			; load next virtual sprite y coord
	cmp #MAX_SPRITE_Y		; check that sprite ycoord is visible
	bcs sprite_mux_irqs_prepared	; if too big, stop further displaying
	inc SPRITE_MUX_SORT_INDEX	; advance to next sorted index
	sta sprite_sorted_y+8,y		; save sorted y for later use (overwritten if sprite is skipped)
	lda sprite_sorted_y,y		; load sorted y of current slot (8 sprites before!)
	adc #SPRITE_Y_DISTANCE		; C=0 here, also afterwards, compute end of sprite display of that slot
	cmp sprite_sorted_y+8,y		; compare against current sprite y
	bcs sprite_mux_prepare_next_vsprite	; sprite would be 9th in rasterline, skip it!
	; sprite can be displayed - check if in this irq or new irq
	cmp SPRITE_MUX_CURRENT_RL	; compare y of last slot + 21 < current rasterline ?
	bcc sprite_mux_prepare_same_irq	; same irq can be used if this slot has finished drawing
	; need new irq
	lda SPRITE_MUX_CURRENT_RL	; load current raster line
	beq +				; if 0, this is first irq
	; not first (new) irq, finish last one
	; read the current irq rasterline start and store it for the slot at irq begin
	lda SPRITE_MUX_CURRENT_RL
	ldx SLOT_NR_IRQ_BEGIN
	sta slot_raster,x
	; prepare xhigh value
	lda SPRITE_MUX_XHVAL
	sta slot_d010,x			; store at matching slot
	sty SLOT_NR_IRQ_BEGIN		; memorize for next irq
	+set8im SPRITE_MUX_NRSPRINIRQ, 0	; 0 sprites in this irq
	; set highest bit of last written color to flag end of irq!
	lda slot_col-1,y		; write to slot before, so -1 here
	ora #$80
	sta slot_col-1,y
+
	lda #$FF			; real value is set later, use neutral value for mininum computation.
	sta SPRITE_MUX_CURRENT_RL	; save as rasterline
sprite_mux_prepare_same_irq
	ldx SPRITE_MUX_SORT_INDEX	; set x again to sort order
	lda sprite_sort_order-1,x	; -1 because y alreadly inc'd
	tax
	lda vsprite_xl,x
	sta slot_xl,y
	lda vsprite_ptr,x
	sta slot_ptr,y
	lda vsprite_col,x
	sta slot_col,y
	lda SPRITE_MUX_XHVAL		; xhigh
	and bit_nand_table,y		; slotnumber (NUM_VSPRITES-8 sized!)
	sta SPRITE_MUX_XHVAL
	lda vsprite_xh,x
	beq +
	lda SPRITE_MUX_XHVAL
	ora bit_or_table,y
	sta SPRITE_MUX_XHVAL
+	
	; load sprite y and decrease by offset depending on number of sprites in interrupt
	lda vsprite_y,x
	ldx SPRITE_MUX_NRSPRINIRQ
	sec
	sbc sprite_mux_irq_lines_before_sprite,x
	; compare if that is lower than current irq raster start, if so, use it
	cmp SPRITE_MUX_CURRENT_RL
	bcs +
	sta SPRITE_MUX_CURRENT_RL
+
	inc SPRITE_MUX_NRSPRINIRQ	; sprite handled
	iny				; use next slot
!if DEBUG_TIMING {
	inc VICBGCOL
}
	jmp sprite_mux_prepare_next_vsprite

sprite_mux_irqs_prepared
!if DEBUG_TIMING {
	inc VICBGCOL
}
	; store the irq start raster line for that slot
	lda SPRITE_MUX_CURRENT_RL
	ldx SLOT_NR_IRQ_BEGIN
	sta slot_raster,x				; to slot where irq begun
	; set xhigh value of last irq
	lda SPRITE_MUX_XHVAL
	sta slot_d010,x
	; if all virtual sprites are handled but not all slots used because some
	; sprites are skipped because of 9th sprite in a row or too small y coordinates
	; we have to signal the end of all irqs by setting 7th bit of color of last slot
	; and setting the next raster line to 0 as marker.
	; In that case y has not reached maximum value
	cpy #(NR_OF_VIRTUAL_SPRITES-8)
	beq +
	lda slot_col-1,y		; write to slot before, so -1 here
	ora #$80
	sta slot_col-1,y
	lda #0
	sta slot_raster,y
+	; how can we check that only 8 sprites are drawn and no irq is needed? slot nr is 0!
	; but xh is then already written, but that doesn't hurt, its the actual value
	cpy #0	; maybe tya works as well
	bne +
	; only 8 sprites are drawn, set jump target to do nothing address
	+set16im $FFFE, sprite_mux_irq_dummy
	; doesn't matter when irq is triggered
	bne ++	; highbyte is !0, so always jumps
+	lda slot_raster
	sei
	sta VICRASTER
	+set16im $FFFE, sprite_mux_irq	; raster irq visits that address
	cli
	; set end marker for last irq (high bit of color) is not needed
++

; we need to set the hibyte of the screen address for all virtual sprites!
; so one load and 16-32 stores.
	lda #$07		; hibyte of screen address
!for COUNT, 0, 7 {
	sta sprite_mux_set_first8+COUNT*FIRST8_SIZE+FIRST8_SCREEN_ADR
}
!for COUNT, 8, NR_OF_VIRTUAL_SPRITES-1 {
	sta sprite_mux_irq_unroll+MUXIRQ_SIZE*(COUNT-8)+MUXIRQ_SCREEN_ADR
}
!if DEBUG_TIMING {
	+set8im VICBGCOL,14
}
	rts


; ******************************************
; the magic sprite mux irq
; ******************************************
MIN_RASTER_LINES_BETWEEN_IRQS = 3	; with 2 we miss rasterlines/irqs and many sprites are missing
UNROLL_FULL_IRQ = 0
sprite_mux_irq
!if DEBUG_TIMING {
	inc VICBGCOL
}
	pha				; save accu
	lda slot_d010			; load xhigh for irq start at that slot
	sta $D010			; set xhigh for this irq
sprite_mux_irq_unroll
	; unroll one iteration less than needed, last iteration is shorter and manually unrolled.
	; note that the instructions must be identical in the last iteration to make it work!
!for COUNT, 0, NR_OF_VIRTUAL_SPRITES-2-8 {
!zone {
.adrstart
	lda sprite_sorted_y + COUNT + 8	; load y coord
	sta $D001+(COUNT & 7)*2		; set for hardware sprite
	lda slot_xl + COUNT		; load xl coord
	sta $D000+(COUNT & 7)*2		; set for hardware sprite
	lda slot_ptr + COUNT		; load sprite pointer
	sta $07F8+(COUNT & 7)		; set in register
.adrp1
	lda slot_col + COUNT		; load color
	sta $D027+(COUNT & 7)		; set in register
	bpl ++				; if highbit set irq ends, so highbit clear, do next slot
	lda slot_raster + COUNT+1	; load next irq raster line, next so +1
!if UNROLL_FULL_IRQ {
	; when accu is 0 so zero bit is set, no new irq needs to be called
	; but the last one needs to end!
	bne +
	jmp sprite_mux_irq_last_done
+	sta VICRASTER			; set as irq trigger
	cld
	sec				; check if we are late for next irq!
	sbc #MIN_RASTER_LINES_BETWEEN_IRQS
	cmp VICRASTER
	; if C=0 we are too late for next irq, but do not start it BEFORE the
	; stored raster line or it will be too early!
	; if we are too late for the irq all displaying fails from here on
	bcc +				; if carry set, VICRASTER <= next_rasterline - 2, so end IRQ
	+set16im $FFFE, +++ 		; sprite_mux_irq_next_start
	pla		; restore accu
	asl $D019	; ack irq
!if DEBUG_TIMING {
	dec VICBGCOL
}
	rti
+	adc #(MIN_RASTER_LINES_BETWEEN_IRQS-1)	; C=0, prepare check VICRASTER <= next_rasterline - 1
inc VICFGCOL;fixme
-	cmp VICRASTER			; as long as we are in line before, do busy waiting
	bcs -
dec VICFGCOL;fixme
	bcc +				; directly jump to next irq code (always branches)
} else {
	jsr sprite_mux_irq_prepare_next	; save address for next irq or returns if late
	bcc +				; carry is clear from caller, so this always branches
}
+++
!if DEBUG_TIMING {
	inc VICBGCOL
}
	pha				; save accu
+	lda slot_d010 + COUNT+1		; load xhigh for irq start at that slot
	sta $D010			; set xhigh for this irq
++
.adrend
MUXIRQ_SIZE = .adrend - .adrstart
MUXIRQ_SCREEN_ADR = .adrp1 - 1 - .adrstart
} ; zone
} ; for
; Now iteration for COUNT=NR_OF_VIRTUAL_SPRITES-1-8 manually unrolled, only
; a few instructions. Must be identical to unrolled irq code!
!zone {
.COUNT=NR_OF_VIRTUAL_SPRITES-1-8
	lda sprite_sorted_y + .COUNT + 8	; load y coord
	sta $D001+(.COUNT & 7)*2		; set for hardware sprite
	lda slot_xl + .COUNT		; load xl coord
	sta $D000+(.COUNT & 7)*2		; set for hardware sprite
	lda slot_ptr + .COUNT		; load sprite pointer
	sta $07F8+(.COUNT & 7)		; set in register
	lda slot_col + .COUNT		; load color
	sta $D027+(.COUNT & 7)		; set in register
}
sprite_mux_irq_last_done
	; last irq is done, set rasterline to scoreline panel
	; set irq address to do nothing or draw scoreline panel
	; then end irq
	+set16im $FFFE, sprite_mux_irq_dummy	; later scoreline
	;lda #scorelineraster
	;sta VICRASTER
	pla
!if DEBUG_TIMING {
	dec VICBGCOL
}
sprite_mux_irq_dummy
	asl $D019
	rti

sprite_mux_irq_prepare_next
	; when accu is 0 so zero bit is set, no new irq needs to be called
	; but the last one needs to end!
	bne +
	pla				; undo jsr
	pla				; undo jsr
	jmp sprite_mux_irq_last_done
+	sta VICRASTER			; set as irq trigger
	cld				; needed, as the main program can use decimal mode anywhere
	sec				; check if we are late for next irq!
	sbc #MIN_RASTER_LINES_BETWEEN_IRQS
	cmp VICRASTER
	; if C=0 we are too late for next irq, but do not start it BEFORE the
	; stored raster line or it will be too early!
	; if we are too late for the irq all displaying fails from here on
	bcs sprite_mux_irq_done		; if carry set, VICRASTER <= next_rasterline - 2, so end IRQ
	adc #(MIN_RASTER_LINES_BETWEEN_IRQS-1)	; C=0, prepare check VICRASTER <= next_rasterline - 1
inc VICFGCOL;fixme
-	cmp VICRASTER			; as long as we are in line before, do busy waiting
	bcs -
dec VICFGCOL;fixme
	rts				; return to unrolled code to continue irq.
sprite_mux_irq_done			; set up next irq vector from saved address and end irq
	pla
	clc
	adc #3
	sta $FFFE	; need to add 1 to address, because of the way JSR works, +2 to skip the bcc.
	pla
	adc #0
	sta $FFFF
	pla		; restore accu
	asl $D019	; ack irq
!if DEBUG_TIMING {
	dec VICBGCOL
}
; fixme: was this comment about full unroll or not? seems so... maybe have 2 versions of the irq
; in code, even with code duplication, full unrolled vs. partially unrolled.
; otherwise its hard to understand.
; then comment costs and size

; fixme, make irq quicker: jsr 6, pla 4, clc 2, adc 2, pla 4, adc 2 avoided -> 20 cycles saved.
; last irq: jsr,pla,pla saved: 14 cycles saved.
; late: jsr,rts saved but we need cld (12-2), 10 cycles saved.
; fixme unroll always or per code switch? try with a copy of the code and check size!
; it may cost 500 bytes?!
; it costs 77 bytes for one unroll part (16 or 24 parts for 24 or 32 sprites) with debug output. (1232/1848)
; $47=71 bytes for one unroll part w/o debug output: 1136/1704 bytes.
; with usual numbers (16) full unrolling takes 1136 bytes. not fully unrolled:
; $23 = 35 bytes per block plus extra code. hmm measured separately: $262=610 bytes
; 16*35=560, extra code 50 bytes. So with 32 sprites: 890. So not fully unrolled: 560/890 bytes. Compared to 1136/1704.
; code size nearly doubles for a few cycles. unroll it fully and then test if its worth.
; yes, 15-20 cycles less are realistic, but it doesn't help for tight sprite formations to reduce the busy waiting.
; so clearly not worth it!
	rti
sprite_mux_irq_code_end

