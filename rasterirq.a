; Bacillus_c64
; Copyright (C) 2016-2017  Thorsten Jordan.
; 
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

; ***************************************************************************************
;
; All stuff related to raster interrupt handling
;
; ***************************************************************************************

; IMPORTANT
; Raster lines are shifted to sprite coordinates by 1 !
; First visible raster line at top of screen is $33 = 51, but sprite coordinate there is 50 !
; So we have to handle this!!!
; Also note that when we request a raster IRQ for line X, it takes many cycles to save registers
; and call own routine (from kernal) so we are late in line X, sometimes even early in line X+1.
; (We could save some time by disabling kernal).
; However to be stable at begin of a certain line, we have to busy wait for line X+2.
; So we have to trigger raster IRQ two lines before we need it.
; Also busy waiting should be done with >= comparison and not == / != in case a line is missed.
; This is done with the scheme:
; lda #LINE
; - cmp VICRASTER
; bcs -
; To react as soon as possible to a line change. But "bcs" goes back as long as LINE >= VICRASTER,
; so we have to load a value ONE LESS than the desired line!
; Beware also that decimal flag may be set, so if we compute something in IRQ, we need to run cld
; first!

SCORE_LINE_Y = 243
BLEND_IN_FIRST_LINE = 51+42-4

; ------------------------------- Set up the raster IRQ for score line, setup generic IRQ handling
setup_rasterirq
	sei
	+set16im $0314, rasterirq_scoreline	; set vector to interrupt routine
	+set8im VICRASTER, SCORE_LINE_Y-2
	lda VICCTRL1		; clear 9th bit of raster line selector
	and #$7F
	sta VICCTRL1
	+set8im $D01A, $01	; Set only raster as source for IRQ of VIC
	lda #$7F		; disable timer IRQs
	sta $DC0D
	lda $DC0D
	+set8im $D019, $01	; Acknowledge possible pending raster irq
	cli
	rts

; ------------------------------- Set up the raster IRQ for score line etc.
setup_rasterirq_blendin
	sei
	+set16im $0314, rasterirq_blend_in
	+set8im VICRASTER, BLEND_IN_FIRST_LINE
	cli
	rts

; ------------------------------- Set up the raster IRQ for score line etc.
setup_rasterirq_scoreline
	sei
	+set16im $0314, rasterirq_scoreline
	+set8im VICRASTER, SCORE_LINE_Y-2
	cli
	rts

; ----------------------------------- Interrupt routine for score line drawing
rasterirq_scoreline
; We disabled all IRQ sources, so we only have raster IRQs here!
;	lda $D019		; check if IRQ was from raster line
;	bmi dorasterirq		; Bit 7 set: raster IRQ was interrupt reason
;	lda $DC0D		; ACK other irq
;	cli			; enable IRQs
;	jmp $EA31		; jump to system IRQ handler
; Note that if we would disable kernal rom as well, system would directly jump
; to our interrupt handler which means 2-9 cycles after raster line occours.
; Register storing needs to be done then anyway. Additional 14 cycles (ca.)
; Are used in kernal to check for BRK flag, which we don't have.
	; score panel reached, so raster is somewhere on or after SCORE_LINE_Y-2
	lda #(SCORE_LINE_Y-1)	; loop until raster line is <= SCORE_LINE_Y-1, so < SCORE_LINE_Y
-	cmp VICRASTER
	bcs -
	; We are now stable in SCORE_LINE_Y
	; set first background color already, so it is stable
	+copy8 VICFGCOL, rasterbar_colors
	; Set scroll to neutral for score panel
	; Note that this command seems to delay current raster line...
	+set8im VICCTRL2, $10
	; Now wait for next raster lines and set color then
!for COUNT, 0, 7 {
	ldx rasterbar_colors+COUNT
	lda #(SCORE_LINE_Y+COUNT)
-	cmp VICRASTER
	bcs -
	stx VICFGCOL
}
	; We are now in line 251, below visible screen.
	; restore scroll register
	+copy8 VICCTRL2, last_value_of_vicctrl2
rasterirq_ack_and_end
	lda #$01
	sta $D019		; clear interrupt flag - do it at end or other raster IRQs could occur!
	pla			; could do jmp $EA81 here.
	tay
	pla
	tax
	pla
	rti

last_value_of_vicctrl2
!byte 0

rasterbar_colors
!byte 6,14,13,1,13,14,6, 9

; -------------------------------- IRQ routine for blend in/out sprite multiplexer
rasterirq_blend_in
	; raster irq that is called near end of display of one row of sprites
	; Sprites have coordinates 50+42*N, N=0...4, so 50,92,134,176,218 and score line at 242.
	; And this are raster lines 51+42*N, so we need to set the sprite pointers in line 51+42*N
	; But Y coord before line 50+42*N, e.g. 49+42*N, or try 50+42*N, so we need to trigger raster at 48+42*N.
	; We trigger at 48+42*N, N=1...4 (90,132,174,216) and at 241.
	; When we arrive here, we are at end of a sprite row, we must set up next Y coordinates for next row
	; and set sprite pointers in time and then set up next IRQ.
rasterirq_blend_in_sprite_y
	lda #(50+42)
!for COUNT, 0, 6 {
	sta $D001+COUNT*2
}
	; Most timing critical is to set sprite pointer, so do that first
	; Just waiting for 50+42*N is too late, so wait for one line less and do some nops
	tay			; These commands take too long, so we need to trigger raster one line before
	dey
	ldx SCREEN0+$03F8	; load and increase sprite pointer
	inx
-	cpy VICRASTER
	bcs -
	; We are now in raster line 51+42*N, set sprite pointers
!for COUNT, 0, 6 {
	stx SCREEN0+$03F8+COUNT
}
	; Now do the less timing critical tasks, like compute next sprite y coordinate.
	lda rasterirq_blend_in_sprite_y+1
	cld
	clc
	adc #42
	; store next row position
	sta rasterirq_blend_in_sprite_y+1
	; transfer to y, -= 2 to set up next raster IRQ
	tay
	dey
	dey
	; but compare if we are already too low (218+42-2=258, so overflow, or y < 50)
	cpy #50
	bcc +
	; set IRQ for next sprite row
	dey;fixme
	sty VICRASTER
	jmp rasterirq_ack_and_end
+	; Last sprite row was set up, reset sprite Y coordinates and set up raster irq for score line
	+set8im VICRASTER, SCORE_LINE_Y-2
	+set16im $0314, rasterirq_blend_in_scoreline
	jmp rasterirq_ack_and_end
rasterirq_blend_in_scoreline
	; same code as in rasterirq_scoreline! Only part afterwards is new. Maybe use one code with flag.
	lda #(SCORE_LINE_Y-1)	; loop until raster line is <= SCORE_LINE_Y-1, so < SCORE_LINE_Y
-	cmp VICRASTER
	bcs -
	; We are now stable in SCORE_LINE_Y
	; set first background color already, so it is stable
	;+copy8 VICFGCOL, rasterbar_colors
	; Set scroll to neutral for score panel
	; Note that this command seems to delay current raster line...
	+set8im VICCTRL2, $10	;fixme seem to be too late! works if that is first command or try -2 above and busy waiting...
	;fixme the command above seems to delay the whole line! that way only slight visual artefacts
	+copy8 VICFGCOL, rasterbar_colors
	; Now wait for next raster lines and set color then
!for COUNT, 0, 7 {
	ldx rasterbar_colors+COUNT
	lda #(SCORE_LINE_Y+COUNT)
-	cmp VICRASTER
	bcs -
	stx VICFGCOL
}
	; We are now in line 251, below visible screen.
	; restore scroll register
	+copy8 VICCTRL2, last_value_of_vicctrl2
	; Now set IRQ vector and raster line and all data we need at end of first row.
	+set16im $0314, rasterirq_blend_in
	+set8im rasterirq_blend_in_sprite_y+1, 50+42
	+set8im VICRASTER, BLEND_IN_FIRST_LINE
	lda #50
	ldx #BLEND_IN_SPRITE_PTR
!for COUNT, 0, 6 {
	sta $D001+COUNT*2		; Set sprite Y coordinates back to default for first row
	stx SCREEN0+$03F8+COUNT		; Reset sprite pointers
}
	jmp rasterirq_ack_and_end

